<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Shy</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23f5f0e8'/><circle cx='50' cy='50' r='28' fill='none' stroke='%232d2a24' stroke-width='3' stroke-dasharray='120 60' stroke-linecap='round'/></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Source+Serif+4:opsz,wght@8..60,300;8..60,400;8..60,500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f5f0e8;
      --bg-warm: #ebe5db;
      --fg: #2d2a24;
      --fg-muted: #7a756b;
      --accent: #c45a3b;
      --surface: #ffffff;
      --surface-hover: #faf8f5;
      --border: #d9d4ca;
      --listening: #c45a3b;
      --success: #5a8a5e;
      --link: #3d6a99;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Source Serif 4', Georgia, serif;
      background: var(--bg);
      color: var(--fg);
    }

    /* Login Screen */
    .login-screen {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.6s ease-out;
    }

    .login-screen.hidden {
      display: none;
    }

    .logo {
      margin-bottom: 1.5rem;
      opacity: 0.7;
    }

    .login-screen h1 {
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 3.5rem;
      font-weight: 300;
      letter-spacing: -0.03em;
      margin-bottom: 0.5rem;
      color: var(--fg);
    }

    .login-screen p {
      font-family: 'IBM Plex Mono', monospace;
      color: var(--fg-muted);
      font-size: 0.7rem;
      font-weight: 400;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      margin-bottom: 3rem;
    }

    .login-btn {
      background: var(--fg);
      color: var(--bg);
      border: none;
      padding: 1rem 2.5rem;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      font-weight: 500;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: all 0.2s ease;
      border-radius: 4px;
    }

    .login-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(45, 42, 36, 0.15);
    }

    .login-btn:active {
      transform: translateY(0);
    }

    /* Main Voice Screen */
    .voice-screen {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .voice-screen.hidden {
      display: none;
    }

    .voice-screen.text-mode::before {
      content: '';
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 180px;
      background: linear-gradient(to bottom, transparent, var(--bg) 70%);
      pointer-events: none;
      z-index: 40;
    }

    /* The Button - Central Control */
    .button-container {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .main-button {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: none;
      background: var(--fg);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 20px rgba(45, 42, 36, 0.25);
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }

    .main-button:hover {
      transform: scale(1.08);
      box-shadow: 0 6px 28px rgba(45, 42, 36, 0.35);
    }

    .main-button:active {
      transform: scale(0.96);
    }

    .main-button svg {
      width: 28px;
      height: 28px;
      stroke: var(--bg);
      stroke-width: 1.75;
      fill: none;
      transition: all 0.2s ease;
    }

    .main-button .stop-icon {
      display: none;
    }

    .main-button .spinner-icon {
      display: none;
      width: 28px;
      height: 28px;
      border: 3px solid rgba(245, 240, 232, 0.3);
      border-top-color: var(--bg);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    /* Button States */
    .main-button.listening {
      background: var(--accent);
      box-shadow: 0 4px 24px rgba(196, 90, 59, 0.4);
    }

    .main-button.listening .mic-icon {
      display: none;
    }

    .main-button.listening .stop-icon {
      display: block;
    }

    .main-button.processing {
      opacity: 0.8;
      cursor: wait;
    }

    .main-button.processing .mic-icon,
    .main-button.processing .stop-icon {
      display: none;
    }

    .main-button.processing .spinner-icon {
      display: block;
    }

    .main-button.speaking {
      background: var(--accent);
      box-shadow: 0 4px 24px rgba(196, 90, 59, 0.4);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Status Text */
    .status-text {
      position: absolute;
      bottom: -50px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--fg-muted);
      white-space: nowrap;
      transition: all 0.3s ease;
    }

    .status-text.listening {
      color: var(--accent);
    }

    .status-text.speaking {
      color: var(--accent);
    }

    /* Hint text below button */
    .hint-text {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.7rem;
      color: var(--fg-muted);
      opacity: 0.6;
      transition: opacity 0.3s ease;
    }

    .hint-text.hidden {
      opacity: 0;
    }

    .hint-text kbd {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.65rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 3px;
      margin: 0 0.15rem;
    }

    /* Bottom Controls */
    .bottom-controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      z-index: 50;
    }

    .control-pill {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.9rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.65rem;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--fg-muted);
    }

    .control-pill:hover {
      border-color: var(--fg-muted);
      color: var(--fg);
    }

    .control-pill.active {
      border-color: var(--link);
      background: rgba(61, 106, 153, 0.1);
      color: var(--link);
    }

    .control-pill svg {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      stroke-width: 1.5;
      fill: none;
    }

    .control-pill.hidden {
      display: none;
    }

    /* Search pill - show on/off state clearly */
    .search-pill .status-indicator {
      font-size: 0.6rem;
      opacity: 0.7;
    }

    .search-pill.active .status-indicator {
      opacity: 1;
    }

    .search-pill .search-label-short {
      display: none;
    }

    /* Stop button special styling */
    .stop-pill {
      border-color: var(--accent);
      color: var(--accent);
    }

    .stop-pill:hover {
      background: rgba(196, 90, 59, 0.1);
    }

    /* New chat button - top left */
    .new-chat-btn {
      position: fixed;
      top: 1.5rem;
      left: 1.5rem;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 100;
    }

    .new-chat-btn:hover {
      border-color: var(--fg-muted);
    }

    .new-chat-btn svg {
      width: 16px;
      height: 16px;
      stroke: var(--fg-muted);
      stroke-width: 2;
      fill: none;
    }

    .new-chat-btn:hover svg {
      stroke: var(--fg);
    }

    .new-chat-btn.hidden {
      display: none;
    }

    /* Settings menu - top right */
    .settings-menu {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      z-index: 100;
    }

    .settings-menu.hidden {
      display: none;
    }

    .settings-menu-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .settings-menu-btn:hover {
      border-color: var(--fg-muted);
    }

    .settings-menu-btn:focus {
      outline: none;
    }

    .settings-menu-btn svg {
      width: 16px;
      height: 16px;
      fill: var(--fg-muted);
    }

    .settings-menu-btn:hover svg {
      fill: var(--fg);
    }

    /* Settings dropdown */
    .settings-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 0.5rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      min-width: 140px;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px);
      transition: all 0.2s ease;
    }

    .settings-dropdown.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .settings-dropdown button {
      width: 100%;
      padding: 0.75rem 1rem;
      background: none;
      border: none;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.7rem;
      font-weight: 500;
      letter-spacing: 0.02em;
      color: var(--fg);
      text-align: left;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      transition: background 0.15s ease;
    }

    .settings-dropdown button:hover {
      background: var(--bg);
    }

    .settings-dropdown button svg {
      width: 14px;
      height: 14px;
      stroke: var(--fg-muted);
      stroke-width: 1.5;
      fill: none;
    }

    .settings-dropdown .divider {
      height: 1px;
      background: var(--border);
    }

    /* Cost Modal */
    .modal-small {
      max-width: 300px;
    }

    .cost-stats {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .cost-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .cost-stat-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      color: var(--fg-muted);
    }

    .cost-stat-value {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--fg);
      font-variant-numeric: tabular-nums;
    }

    /* Voice Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(45, 42, 36, 0.4);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .modal-overlay.hidden {
      display: none;
    }

    .modal {
      background: var(--surface);
      border-radius: 8px;
      width: 100%;
      max-width: 440px;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1.25rem 1.5rem;
      border-bottom: 1px solid var(--border);
    }

    .modal-header h3 {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--fg);
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 1.25rem;
      color: var(--fg-muted);
      cursor: pointer;
      line-height: 1;
      padding: 0;
      transition: color 0.15s ease;
    }

    .modal-close:hover {
      color: var(--fg);
    }

    .modal-body {
      padding: 1rem;
      overflow-y: auto;
    }

    .voice-list {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .voice-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.65rem 0.9rem;
      background: var(--bg);
      border: 1px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .voice-item:hover {
      background: var(--bg-warm);
    }

    .voice-item.selected {
      border-color: var(--accent);
      background: rgba(196, 90, 59, 0.1);
    }

    .voice-radio {
      width: 14px;
      height: 14px;
      border: 1.5px solid var(--border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .voice-item.selected .voice-radio {
      border-color: var(--accent);
    }

    .voice-item.selected .voice-radio::after {
      content: '';
      width: 6px;
      height: 6px;
      background: var(--accent);
      border-radius: 50%;
    }

    .voice-info {
      flex: 1;
      min-width: 0;
    }

    .voice-name {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--fg);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .voice-lang {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.6rem;
      color: var(--fg-muted);
      margin-top: 0.1rem;
    }

    .voice-preview {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--fg-muted);
      padding: 0.35rem 0.6rem;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.6rem;
      font-weight: 500;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .voice-preview:hover {
      border-color: var(--fg-muted);
      color: var(--fg);
    }

    .voice-cloud-badge,
    .voice-recommended-badge {
      font-size: 0.55rem;
      color: var(--fg-muted);
      background: var(--bg);
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      margin-left: 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .voice-recommended-badge {
      color: var(--success);
      background: rgba(90, 138, 94, 0.1);
    }

    /* Voice help */
    .voice-help {
      padding: 0 0.5rem 0.75rem;
    }

    .voice-help-btn {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      background: none;
      border: none;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.65rem;
      color: var(--link);
      cursor: pointer;
      padding: 0;
    }

    .voice-help-btn:hover {
      text-decoration: underline;
    }

    .voice-help-content {
      margin-top: 0.6rem;
      padding: 0.75rem;
      background: var(--bg);
      border-radius: 4px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.65rem;
      line-height: 1.5;
      color: var(--fg-muted);
    }

    .voice-help-content.hidden {
      display: none;
    }

    .voice-help-content p {
      margin: 0 0 0.5rem;
    }

    .voice-help-content p:last-child {
      margin-bottom: 0;
    }

    .voice-help-content strong {
      color: var(--fg);
    }

    /* Current voice display */
    .current-voice {
      padding: 0.75rem;
      margin: 0 0.5rem 0.75rem;
      background: var(--bg);
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .current-voice-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.65rem;
      color: var(--fg-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .current-voice-name {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--fg);
    }

    /* Cloud toggle */
    .cloud-toggle {
      padding: 0 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      margin-bottom: 0.75rem;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      gap: 1rem;
    }

    .toggle-label {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }

    .toggle-title {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--fg);
    }

    .toggle-desc {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.6rem;
      color: var(--fg-muted);
    }

    .toggle-row input {
      display: none;
    }

    .toggle-switch {
      width: 36px;
      height: 20px;
      background: var(--border);
      border-radius: 10px;
      position: relative;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: var(--surface);
      border-radius: 50%;
      transition: transform 0.2s ease;
    }

    .toggle-row input:checked + .toggle-switch {
      background: var(--accent);
    }

    .toggle-row input:checked + .toggle-switch::after {
      transform: translateX(16px);
    }

    /* Error Toast */
    .error-toast {
      position: fixed;
      bottom: 6rem;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--surface);
      border: 1px solid var(--accent);
      padding: 0.75rem 1.25rem;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      color: var(--accent);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 200;
      border-radius: 4px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      pointer-events: none;
    }

    .error-toast.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Conversation History */
    .conversation-history {
      position: fixed;
      inset: 0;
      overflow-y: auto;
      padding: 4.5rem 1.5rem 12rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      z-index: 1;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      -webkit-overflow-scrolling: touch;
    }

    .conversation-history.visible {
      opacity: 1;
      visibility: visible;
    }

    .conversation-history::-webkit-scrollbar {
      width: 4px;
    }

    .conversation-history::-webkit-scrollbar-track {
      background: transparent;
    }

    .conversation-history::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .message-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-width: 640px;
      width: 100%;
      margin: 0 auto;
    }

    .message {
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 1rem;
      line-height: 1.6;
      animation: messageIn 0.3s ease-out;
    }

    @keyframes messageIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.user {
      color: var(--fg);
      background: var(--surface);
      padding: 1rem 1.25rem;
      border-radius: 1rem;
      border: 1px solid var(--border);
    }

    .message.assistant {
      color: var(--fg);
    }

    .message.assistant h1,
    .message.assistant h2,
    .message.assistant h3,
    .message.assistant h4 {
      font-family: 'Source Serif 4', Georgia, serif;
      font-weight: 500;
      margin: 0.75em 0 0.25em;
      line-height: 1.3;
    }

    .message.assistant h1:first-child,
    .message.assistant h2:first-child,
    .message.assistant h3:first-child {
      margin-top: 0;
    }

    .message.assistant h1 { font-size: 1.4em; }
    .message.assistant h2 { font-size: 1.25em; }
    .message.assistant h3 { font-size: 1.1em; }
    .message.assistant h4 { font-size: 1em; }

    .message.assistant p {
      margin: 0.5em 0;
    }

    .message.assistant p:first-child {
      margin-top: 0;
    }

    .message.assistant p:last-child {
      margin-bottom: 0;
    }

    .message.assistant ul,
    .message.assistant ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
    }

    .message.assistant li {
      margin: 0.25em 0;
    }

    .message.assistant code {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.9em;
      background: var(--bg-warm);
      padding: 0.15em 0.35em;
      border-radius: 3px;
    }

    .message.assistant pre {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85em;
      background: var(--bg-warm);
      padding: 0.75em 1em;
      border-radius: 4px;
      overflow-x: auto;
      margin: 0.5em 0;
    }

    .message.assistant pre code {
      background: none;
      padding: 0;
    }

    .message.assistant a {
      color: var(--link);
      text-decoration: none;
    }

    .message.assistant a:hover {
      text-decoration: underline;
    }

    .message.assistant strong {
      font-weight: 600;
    }

    .message.assistant em {
      font-style: italic;
    }

    .message.assistant blockquote {
      border-left: 3px solid var(--border);
      margin: 0.5em 0;
      padding-left: 1em;
      color: var(--fg-muted);
    }

    .message.assistant hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 1em 0;
    }

    .message.streaming::after {
      content: '▊';
      animation: blink 0.8s steps(2) infinite;
      color: var(--accent);
      margin-left: 2px;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Text Input Mode */
    .text-input-container {
      position: fixed;
      bottom: 5.5rem;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 3rem);
      max-width: 560px;
      display: none;
      z-index: 50;
      transition: bottom 0.15s ease-out;
    }

    .text-input-container.visible {
      display: block;
    }

    .text-input-wrapper {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 24px rgba(45, 42, 36, 0.1);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      padding: 8px;
      padding-left: 0;
    }

    .text-input-wrapper:focus-within {
      border-color: var(--fg-muted);
      box-shadow: 0 6px 32px rgba(45, 42, 36, 0.15);
    }

    .text-input {
      flex: 1;
      height: 36px;
      max-height: 160px;
      padding: 0 0 0 1rem;
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 1rem;
      line-height: 36px;
      color: var(--fg);
      background: transparent;
      border: none;
      resize: none;
      outline: none;
      field-sizing: content;
    }

    .text-input::placeholder {
      color: var(--fg-muted);
      opacity: 0.6;
    }

    .text-send-btn {
      flex-shrink: 0;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: var(--fg);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      opacity: 0.4;
    }

    .text-send-btn:hover {
      transform: scale(1.05);
      opacity: 0.8;
    }

    .text-send-btn.active {
      opacity: 1;
      background: var(--accent);
    }

    .text-send-btn.active:hover {
      transform: scale(1.08);
      box-shadow: 0 2px 12px rgba(196, 90, 59, 0.3);
    }

    .text-send-btn svg {
      width: 16px;
      height: 16px;
      stroke: var(--bg);
      stroke-width: 2;
      fill: none;
    }

    .text-send-btn .spinner-icon {
      display: none;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(245, 240, 232, 0.3);
      border-top-color: var(--bg);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .text-send-btn.loading svg {
      display: none;
    }

    .text-send-btn.loading .spinner-icon {
      display: block;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 20px;
    }

    .mode-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 28px;
      border: none;
      background: transparent;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .mode-btn svg {
      width: 14px;
      height: 14px;
      stroke: var(--fg-muted);
      stroke-width: 1.5;
      fill: none;
      transition: stroke 0.2s ease;
    }

    .mode-btn:hover svg {
      stroke: var(--fg);
    }

    .mode-btn.active {
      background: var(--fg);
    }

    .mode-btn.active svg {
      stroke: var(--bg);
    }

    /* Text mode adjustments */
    .voice-screen.text-mode .button-container {
      display: none;
    }

    .voice-screen.text-mode .hint-text {
      display: none;
    }

    /* Ensure cost and menu float above conversation */
    .cost-display {
      z-index: 100;
    }

    /* Mobile */
    @media (max-width: 600px) {
      .main-button {
        width: 72px;
        height: 72px;
      }

      .hint-text {
        display: none;
      }

      .bottom-controls {
        bottom: 1.5rem;
      }

      .cost-display {
        left: 1rem;
        font-size: 0.55rem;
      }

      .settings-menu {
        top: 1rem;
        right: 1rem;
      }

      .new-chat-btn {
        top: 1rem;
        left: 1rem;
      }

      .text-input-container {
        bottom: 5.5rem;
        width: calc(100% - 2rem);
      }

      .text-input {
        font-size: 16px; /* Prevent iOS zoom */
      }

      .conversation-history {
        padding: 4rem 1rem 10rem;
      }

      .message {
        font-size: 0.95rem;
      }

      .search-pill .search-label-long {
        display: none;
      }

      .search-pill .search-label-short {
        display: inline;
      }
    }
  </style>
</head>
<body>
  <!-- Cost Modal -->
  <div class="modal-overlay hidden" id="costModal">
    <div class="modal modal-small">
      <div class="modal-header">
        <h3>Cost</h3>
        <button class="modal-close" id="costModalClose">&times;</button>
      </div>
      <div class="modal-body">
        <div class="cost-stats">
          <div class="cost-stat">
            <span class="cost-stat-label">OpenRouter balance</span>
            <span class="cost-stat-value" id="costBalance">—</span>
          </div>
          <div class="cost-stat">
            <span class="cost-stat-label">Last message</span>
            <span class="cost-stat-value" id="costLast">—</span>
          </div>
          <div class="cost-stat">
            <span class="cost-stat-label">This session</span>
            <span class="cost-stat-value" id="costSession">$0.00</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Voice Settings Modal -->
  <div class="modal-overlay hidden" id="voiceModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Voice Settings</h3>
        <button class="modal-close" id="modalClose">&times;</button>
      </div>
      <div class="modal-body">
        <div class="current-voice" id="currentVoice">
          <span class="current-voice-label">Current:</span>
          <span class="current-voice-name" id="currentVoiceName">None selected</span>
        </div>
        <div class="cloud-toggle">
          <label class="toggle-row">
            <span class="toggle-label">
              <span class="toggle-title">Cloud voices</span>
              <span class="toggle-desc">Higher quality, but text is sent to third party services</span>
            </span>
            <input type="checkbox" id="cloudVoicesToggle">
            <span class="toggle-switch"></span>
          </label>
        </div>
        <div class="voice-help" id="voiceHelp">
          <button class="voice-help-btn" id="voiceHelpBtn">
            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="1.5" fill="none">
              <circle cx="12" cy="12" r="10"/>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
              <line x1="12" y1="17" x2="12.01" y2="17"/>
            </svg>
            How to install better voices
          </button>
          <div class="voice-help-content hidden" id="voiceHelpContent">
            <p><strong>macOS:</strong> System Settings → Accessibility → Spoken Content → System Voice → Manage Voices</p>
            <p><strong>iOS:</strong> Settings → Accessibility → Spoken Content → Voices → English</p>
            <p>Download voices marked "Premium" or "Enhanced" for best quality.</p>
          </div>
        </div>
        <div class="voice-list" id="voiceList"></div>
      </div>
    </div>
  </div>

  <!-- Login Screen -->
  <div class="login-screen" id="loginScreen">
    <div class="logo">
      <svg width="48" height="48" viewBox="0 0 100 100">
        <circle cx="50" cy="50" r="28" fill="none" stroke="var(--fg)" stroke-width="4" stroke-dasharray="120 60" stroke-linecap="round"/>
      </svg>
    </div>
    <h1>Shy</h1>
    <p>Private voice for AI</p>
    <button class="login-btn" id="loginBtn">Connect with OpenRouter</button>
  </div>

  <!-- Main Voice Screen -->
  <div class="voice-screen hidden" id="voiceScreen">
    <!-- New Chat Button -->
    <button class="new-chat-btn hidden" id="newChatBtn" title="New chat">
      <svg viewBox="0 0 24 24">
        <path d="M23 4v6h-6"/>
        <path d="M1 20v-6h6"/>
        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
      </svg>
    </button>

    <!-- Conversation History -->
    <div class="conversation-history" id="conversationHistory"></div>

    <!-- Text Input -->
    <div class="text-input-container" id="textInputContainer">
      <div class="text-input-wrapper">
        <textarea class="text-input" id="textInput" placeholder="Type your message..." rows="1"></textarea>
        <button class="text-send-btn" id="textSendBtn">
          <svg viewBox="0 0 24 24">
            <line x1="22" y1="2" x2="11" y2="13"/>
            <polygon points="22 2 15 22 11 13 2 9 22 2"/>
          </svg>
          <div class="spinner-icon"></div>
        </button>
      </div>
    </div>

    <!-- The Button -->
    <div class="button-container">
      <button class="main-button" id="mainButton">
        <svg class="mic-icon" viewBox="0 0 24 24">
          <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
          <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          <line x1="12" y1="19" x2="12" y2="23"/>
          <line x1="8" y1="23" x2="16" y2="23"/>
        </svg>
        <svg class="stop-icon" viewBox="0 0 24 24">
          <rect x="6" y="6" width="12" height="12" rx="1"/>
        </svg>
        <div class="spinner-icon"></div>
      </button>
      <div class="status-text" id="statusText">Ready</div>
    </div>

    <!-- Hint -->
    <div class="hint-text" id="hintText">
      Press <kbd>space</kbd> or tap the button to speak
    </div>

    <!-- Settings menu - top right -->
    <div class="settings-menu" id="settingsMenu">
      <button class="settings-menu-btn" id="settingsMenuBtn" title="Settings">
        <svg viewBox="0 0 24 24">
          <circle cx="12" cy="5" r="1.5"/>
          <circle cx="12" cy="12" r="1.5"/>
          <circle cx="12" cy="19" r="1.5"/>
        </svg>
      </button>
      <div class="settings-dropdown" id="settingsDropdown">
        <button id="voiceSettingsBtn">
          <svg viewBox="0 0 24 24">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          </svg>
          Voice
        </button>
        <button id="costSettingsBtn">
          <svg viewBox="0 0 24 24">
            <line x1="12" y1="1" x2="12" y2="23"/>
            <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
          </svg>
          Cost
        </button>
        <button id="copyChatBtn">
          <svg viewBox="0 0 24 24">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy chat
        </button>
        <div class="divider"></div>
        <button id="logoutBtn">
          <svg viewBox="0 0 24 24">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
            <polyline points="16 17 21 12 16 7"/>
            <line x1="21" y1="12" x2="9" y2="12"/>
          </svg>
          Logout
        </button>
      </div>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls" id="bottomControls">
      <!-- Mode Toggle -->
      <div class="mode-toggle" id="modeToggle">
        <button class="mode-btn active" id="voiceModeBtn" title="Voice mode">
          <svg viewBox="0 0 24 24">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          </svg>
        </button>
        <button class="mode-btn" id="textModeBtn" title="Text mode">
          <svg viewBox="0 0 24 24">
            <path d="M4 7V4h16v3"/>
            <path d="M9 20h6"/>
            <path d="M12 4v16"/>
          </svg>
        </button>
      </div>

      <button class="control-pill search-pill" id="searchToggle">
        <svg viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="8"/>
          <line x1="21" y1="21" x2="16.65" y2="16.65"/>
        </svg>
        <span class="search-label-long">Web Search</span>
        <span class="search-label-short">Search</span>
        <span class="status-indicator" id="searchStatus">off</span>
      </button>
      <button class="control-pill stop-pill hidden" id="stopBtn">
        <svg viewBox="0 0 24 24">
          <rect x="6" y="6" width="12" height="12" rx="1"/>
        </svg>
        <span>Stop</span>
      </button>
    </div>
  </div>


  <div class="error-toast" id="errorToast"></div>

  <script>
    // ============ Configuration ============
    const OPENROUTER_AUTH_URL = 'https://openrouter.ai/auth';
    const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1';
    const MODEL = 'google/gemini-3-flash-preview';
    const MODEL_ONLINE = 'google/gemini-3-flash-preview:online';
    const CALLBACK_URL = window.location.origin + window.location.pathname;

    // ============ State ============
    let apiKey = localStorage.getItem('openrouter_api_key');
    let isListening = false;
    let conversationHistory = [];
    let mediaRecorder = null;
    let audioChunks = [];
    let audioStream = null;
    let selectedVoiceName = localStorage.getItem('selectedVoice') || null;
    let webSearchEnabled = localStorage.getItem('webSearchEnabled') === 'true';
    let cloudVoicesEnabled = localStorage.getItem('cloudVoicesEnabled') === 'true';
    let speechQueue = [];
    let isSpeaking = false;
    let shouldStopSpeaking = false;
    let textMode = localStorage.getItem('textMode') === 'true';
    let isProcessingText = false;
    let currentStreamingElement = null;

    // Stats
    const stats = {
      sessionCost: 0,
      lastCost: 0
    };

    // ============ DOM Elements ============
    const loginScreen = document.getElementById('loginScreen');
    const voiceScreen = document.getElementById('voiceScreen');
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const mainButton = document.getElementById('mainButton');
    const statusText = document.getElementById('statusText');
    const hintText = document.getElementById('hintText');
    const settingsMenu = document.getElementById('settingsMenu');
    const settingsMenuBtn = document.getElementById('settingsMenuBtn');
    const settingsDropdown = document.getElementById('settingsDropdown');
    const voiceSettingsBtn = document.getElementById('voiceSettingsBtn');
    const searchToggle = document.getElementById('searchToggle');
    const searchStatus = document.getElementById('searchStatus');
    const stopBtn = document.getElementById('stopBtn');
    const voiceModal = document.getElementById('voiceModal');
    const modalClose = document.getElementById('modalClose');
    const voiceList = document.getElementById('voiceList');
    const costModal = document.getElementById('costModal');
    const costModalClose = document.getElementById('costModalClose');
    const costSettingsBtn = document.getElementById('costSettingsBtn');
    const copyChatBtn = document.getElementById('copyChatBtn');
    const costBalance = document.getElementById('costBalance');
    const costLast = document.getElementById('costLast');
    const costSession = document.getElementById('costSession');
    const errorToast = document.getElementById('errorToast');
    const textInputContainer = document.getElementById('textInputContainer');
    const textInput = document.getElementById('textInput');
    const textSendBtn = document.getElementById('textSendBtn');
    const voiceModeBtn = document.getElementById('voiceModeBtn');
    const textModeBtn = document.getElementById('textModeBtn');
    const conversationHistoryEl = document.getElementById('conversationHistory');
    const newChatBtn = document.getElementById('newChatBtn');

    // ============ Initialization ============
    function init() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');

      if (code) {
        handleOAuthCallback(code);
        return;
      }

      if (apiKey) {
        showVoiceScreen();
      } else {
        showLoginScreen();
      }

      updateSearchToggleUI();
      updateModeUI();
      setupEventListeners();
    }

    // ============ OAuth Flow ============
    function generateCodeVerifier() {
      const array = new Uint8Array(32);
      crypto.getRandomValues(array);
      return btoa(String.fromCharCode(...array))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

    async function generateCodeChallenge(verifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(verifier);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(hash)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

    async function startOAuthFlow() {
      const codeVerifier = generateCodeVerifier();
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      sessionStorage.setItem('code_verifier', codeVerifier);
      const authUrl = `${OPENROUTER_AUTH_URL}?callback_url=${encodeURIComponent(CALLBACK_URL)}&code_challenge=${codeChallenge}&code_challenge_method=S256`;
      window.location.href = authUrl;
    }

    async function handleOAuthCallback(code) {
      const codeVerifier = sessionStorage.getItem('code_verifier');
      if (!codeVerifier) {
        showError('Authentication failed');
        showLoginScreen();
        return;
      }

      try {
        const response = await fetch(`${OPENROUTER_API_URL}/auth/keys`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            code,
            code_verifier: codeVerifier,
            code_challenge_method: 'S256'
          })
        });

        if (!response.ok) throw new Error('Failed to authenticate');

        const data = await response.json();
        apiKey = data.key;
        localStorage.setItem('openrouter_api_key', apiKey);
        sessionStorage.removeItem('code_verifier');
        window.history.replaceState({}, document.title, window.location.pathname);
        showVoiceScreen();
      } catch (error) {
        console.error('OAuth error:', error);
        showError('Authentication failed');
        showLoginScreen();
      }
    }

    function logout() {
      apiKey = null;
      localStorage.removeItem('openrouter_api_key');
      conversationHistory = [];
      showLoginScreen();
    }

    // ============ UI State ============
    function showLoginScreen() {
      loginScreen.classList.remove('hidden');
      voiceScreen.classList.add('hidden');
    }

    function showVoiceScreen() {
      loginScreen.classList.add('hidden');
      voiceScreen.classList.remove('hidden');
    }

    function setButtonState(state) {
      mainButton.classList.remove('listening', 'processing', 'speaking');
      statusText.classList.remove('listening', 'speaking');

      switch (state) {
        case 'listening':
          mainButton.classList.add('listening');
          statusText.classList.add('listening');
          statusText.textContent = 'Listening';
          hintText.classList.add('hidden');
          break;
        case 'processing':
          mainButton.classList.add('processing');
          statusText.textContent = 'Thinking';
          hintText.classList.add('hidden');
          break;
        case 'speaking':
          mainButton.classList.add('speaking');
          statusText.classList.add('speaking');
          statusText.textContent = 'Speaking';
          hintText.classList.add('hidden');
          break;
        default:
          statusText.textContent = 'Ready';
          hintText.classList.remove('hidden');
      }
    }

    function showError(message) {
      errorToast.textContent = message;
      errorToast.classList.add('visible');
      setTimeout(() => errorToast.classList.remove('visible'), 4000);
    }

    function updateSearchToggleUI() {
      searchToggle.classList.toggle('active', webSearchEnabled);
      searchStatus.textContent = webSearchEnabled ? 'on' : 'off';
    }

    function updateSessionCost(cost) {
      stats.lastCost = cost;
      stats.sessionCost += cost;
    }

    async function openCostModal() {
      settingsDropdown.classList.remove('open');
      costModal.classList.remove('hidden');

      // Update session stats
      costLast.textContent = stats.lastCost > 0 ? `$${stats.lastCost.toFixed(5)}` : '—';
      costSession.textContent = `$${stats.sessionCost.toFixed(5)}`;

      // Fetch balance
      costBalance.textContent = '...';
      try {
        const response = await fetch(`${OPENROUTER_API_URL}/credits`, {
          headers: { 'Authorization': `Bearer ${apiKey}` }
        });
        if (response.ok) {
          const data = await response.json();
          const totalCredits = data.data?.total_credits ?? 0;
          const totalUsage = data.data?.total_usage ?? 0;
          const balance = totalCredits - totalUsage;
          costBalance.textContent = `$${balance.toFixed(2)}`;
        } else {
          costBalance.textContent = '—';
        }
      } catch (e) {
        console.warn('Failed to fetch balance:', e);
        costBalance.textContent = '—';
      }
    }

    function closeCostModal() {
      costModal.classList.add('hidden');
    }

    async function copyChat() {
      settingsDropdown.classList.remove('open');

      if (conversationHistory.length === 0) {
        showError('No conversation to copy');
        return;
      }

      let markdown = '';
      for (const msg of conversationHistory) {
        if (msg.role === 'user') {
          markdown += `**You:** ${msg.content}\n\n`;
        } else {
          markdown += `**Assistant:** ${msg.content}\n\n`;
        }
      }

      try {
        await navigator.clipboard.writeText(markdown.trim());
        // Show brief success feedback
        const originalText = copyChatBtn.textContent;
        copyChatBtn.innerHTML = `<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg> Copied!`;
        setTimeout(() => {
          copyChatBtn.innerHTML = `<svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy chat`;
        }, 1500);
      } catch (e) {
        showError('Failed to copy to clipboard');
      }
    }

    // ============ Markdown Parsing ============
    function parseMarkdown(text) {
      if (!text) return '';

      let html = text;

      // Escape HTML first
      html = html
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Code blocks (must be before other processing)
      html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, lang, code) => {
        return `<pre><code>${code.trim()}</code></pre>`;
      });

      // Inline code (must be before other inline processing)
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Headers
      html = html.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
      html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
      html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
      html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

      // Bold and italic (order matters)
      html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
      html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
      html = html.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
      html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
      html = html.replace(/_(.+?)_/g, '<em>$1</em>');

      // Links
      html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

      // Blockquotes
      html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');

      // Horizontal rules
      html = html.replace(/^---$/gm, '<hr>');
      html = html.replace(/^\*\*\*$/gm, '<hr>');

      // Unordered lists
      html = html.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
      html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

      // Ordered lists
      html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
      // Only wrap consecutive <li> that aren't already in <ul>
      html = html.replace(/(<li>.*<\/li>\n?)(?!<\/ul>)/g, (match, p1, offset) => {
        const before = html.substring(0, offset);
        if (before.endsWith('<ul>') || before.match(/<li>.*<\/li>\n?$/)) {
          return match;
        }
        return match;
      });

      // Paragraphs - wrap lines that aren't already wrapped
      const lines = html.split('\n');
      const processed = [];
      let inList = false;

      for (let line of lines) {
        const trimmed = line.trim();
        if (!trimmed) {
          processed.push('');
          continue;
        }

        // Check if line is already an HTML element
        if (trimmed.match(/^<(h[1-4]|ul|ol|li|pre|blockquote|hr|p)/)) {
          processed.push(line);
          continue;
        }

        // Track list state
        if (trimmed.startsWith('<ul>') || trimmed.startsWith('<ol>')) {
          inList = true;
        }
        if (trimmed.endsWith('</ul>') || trimmed.endsWith('</ol>')) {
          inList = false;
        }

        if (inList || trimmed.startsWith('<li>')) {
          processed.push(line);
        } else {
          processed.push(`<p>${trimmed}</p>`);
        }
      }

      html = processed.join('\n');

      // Clean up empty paragraphs and normalize
      html = html.replace(/<p><\/p>/g, '');
      html = html.replace(/\n+/g, '\n');

      return html;
    }

    // ============ New Chat ============
    function startNewChat() {
      conversationHistory = [];
      conversationHistoryEl.innerHTML = '';
      stats.sessionCost = 0;
      stats.lastCost = 0;
      updateNewChatButton();
    }

    function updateNewChatButton() {
      if (conversationHistory.length > 0) {
        newChatBtn.classList.remove('hidden');
      } else {
        newChatBtn.classList.add('hidden');
      }
    }

    // ============ Mode Switching ============
    function updateModeUI() {
      if (textMode) {
        voiceScreen.classList.add('text-mode');
        textInputContainer.classList.add('visible');
        conversationHistoryEl.classList.add('visible');
        voiceModeBtn.classList.remove('active');
        textModeBtn.classList.add('active');
        renderConversationHistory();
        textInput.focus();
      } else {
        voiceScreen.classList.remove('text-mode');
        textInputContainer.classList.remove('visible');
        conversationHistoryEl.classList.remove('visible');
        voiceModeBtn.classList.add('active');
        textModeBtn.classList.remove('active');
      }
    }

    function setTextMode(enabled) {
      textMode = enabled;
      localStorage.setItem('textMode', enabled);
      updateModeUI();
    }

    function renderConversationHistory() {
      conversationHistoryEl.innerHTML = '';

      for (let i = 0; i < conversationHistory.length; i += 2) {
        const userMsg = conversationHistory[i];
        const assistantMsg = conversationHistory[i + 1];

        if (userMsg) {
          const group = document.createElement('div');
          group.className = 'message-group';

          const userEl = document.createElement('div');
          userEl.className = 'message user';
          userEl.textContent = userMsg.content;
          group.appendChild(userEl);

          if (assistantMsg) {
            const assistantEl = document.createElement('div');
            assistantEl.className = 'message assistant';
            assistantEl.innerHTML = parseMarkdown(assistantMsg.content);
            group.appendChild(assistantEl);
          }

          conversationHistoryEl.appendChild(group);
        }
      }

      scrollToBottom();
    }

    function scrollToBottom() {
      conversationHistoryEl.scrollTop = conversationHistoryEl.scrollHeight;
    }

    function addMessageToHistory(role, content, streaming = false) {
      // Find the last message group (skip spacer if present)
      let group = conversationHistoryEl.lastElementChild;
      if (group && group.classList.contains('scroll-spacer')) {
        group = group.previousElementSibling;
      }

      if (role === 'user') {
        // Ensure spacer exists at the end
        let spacer = conversationHistoryEl.querySelector('.scroll-spacer');
        if (!spacer) {
          spacer = document.createElement('div');
          spacer.className = 'scroll-spacer';
          conversationHistoryEl.appendChild(spacer);
        }
        // Spacer height = viewport height so we can scroll the last item to top
        spacer.style.height = conversationHistoryEl.clientHeight + 'px';

        // Create new group for user message, insert before spacer
        group = document.createElement('div');
        group.className = 'message-group';
        conversationHistoryEl.insertBefore(group, spacer);

        const userEl = document.createElement('div');
        userEl.className = 'message user';
        userEl.textContent = content;
        group.appendChild(userEl);

        // Scroll so user message appears at top of visible area
        requestAnimationFrame(() => {
          // Calculate how far the group is from the top of the scrollable content
          // by measuring its position relative to the container and adding current scroll
          const containerTop = conversationHistoryEl.getBoundingClientRect().top;
          const groupTop = group.getBoundingClientRect().top;
          const relativePosition = groupTop - containerTop;
          const scrollTarget = conversationHistoryEl.scrollTop + relativePosition - 72; // 72px = ~4.5rem padding
          conversationHistoryEl.scrollTo({
            top: Math.max(0, scrollTarget),
            behavior: 'smooth'
          });
        });
        return;
      } else {
        // Assistant message goes in the last group
        if (!group) {
          group = document.createElement('div');
          group.className = 'message-group';
          conversationHistoryEl.appendChild(group);
        }

        let assistantEl = group.querySelector('.message.assistant');
        if (!assistantEl) {
          assistantEl = document.createElement('div');
          assistantEl.className = 'message assistant';
          group.appendChild(assistantEl);
        }

        assistantEl.textContent = content;
        if (streaming) {
          assistantEl.classList.add('streaming');
          currentStreamingElement = assistantEl;
        } else {
          assistantEl.classList.remove('streaming');
          currentStreamingElement = null;
        }
      }
    }

    function updateStreamingMessage(content) {
      if (currentStreamingElement) {
        currentStreamingElement.innerHTML = parseMarkdown(content);
      }
    }

    function finishStreamingMessage() {
      if (currentStreamingElement) {
        currentStreamingElement.classList.remove('streaming');
        currentStreamingElement = null;
      }
    }

    // ============ Audio Recording ============
    async function startRecording() {
      try {
        audioChunks = [];

        // Check if mediaDevices API is available
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          console.error('mediaDevices API not available');
          showError('Browser does not support audio recording');
          return;
        }

        // Enumerate devices first to check what's available
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const audioInputs = devices.filter(d => d.kind === 'audioinput');
          console.log('Available audio inputs:', audioInputs);

          if (audioInputs.length === 0) {
            showError('No microphone found. Check browser permissions.');
            setButtonState('ready');
            return;
          }
        } catch (enumError) {
          console.warn('Could not enumerate devices:', enumError);
        }

        // Try with explicit constraints - helps with some Brave configurations
        const constraints = {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        };
        audioStream = await navigator.mediaDevices.getUserMedia(constraints);

        // iOS Safari: unlock audio context and speech synthesis on user gesture
        if (!window.audioUnlocked) {
          // Unlock Web Audio API
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const buffer = audioCtx.createBuffer(1, 1, 22050);
          const source = audioCtx.createBufferSource();
          source.buffer = buffer;
          source.connect(audioCtx.destination);
          source.start(0);

          // Also unlock speechSynthesis with a space character (empty string doesn't work on iOS)
          if (window.speechSynthesis) {
            const unlockUtterance = new SpeechSynthesisUtterance(' ');
            unlockUtterance.volume = 0.01;
            speechSynthesis.speak(unlockUtterance);
          }
          window.audioUnlocked = true;
        }

        let mimeType = 'audio/webm';
        if (MediaRecorder.isTypeSupported('audio/mp4')) {
          mimeType = 'audio/mp4';
        } else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mimeType = 'audio/webm;codecs=opus';
        }

        mediaRecorder = new MediaRecorder(audioStream, { mimeType });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: mimeType });
          audioStream.getTracks().forEach(track => track.stop());
          audioStream = null;

          try {
            const wavBlob = await convertToWav(audioBlob);
            const base64Audio = await blobToBase64(wavBlob);
            await sendAudioToAPI(base64Audio);
          } catch (e) {
            console.error('Audio conversion error:', e);
            showError('Failed to process audio');
            setButtonState('ready');
          }
        };

        mediaRecorder.start();
        isListening = true;
        setButtonState('listening');
        searchToggle.classList.add('hidden');

      } catch (error) {
        console.error('Microphone error:', error);
        showError('Microphone access denied');
        setButtonState('ready');
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      isListening = false;
      setButtonState('processing');
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function convertToWav(audioBlob) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      const wavBuffer = audioBufferToWav(audioBuffer);
      return new Blob([wavBuffer], { type: 'audio/wav' });
    }

    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1;
      const bitDepth = 16;

      let interleaved;
      if (numChannels === 2) {
        const left = buffer.getChannelData(0);
        const right = buffer.getChannelData(1);
        interleaved = new Float32Array(left.length + right.length);
        for (let i = 0, j = 0; i < left.length; i++, j += 2) {
          interleaved[j] = left[i];
          interleaved[j + 1] = right[i];
        }
      } else {
        interleaved = buffer.getChannelData(0);
      }

      const dataLength = interleaved.length * (bitDepth / 8);
      const wavBuffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(wavBuffer);

      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataLength, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
      view.setUint16(32, numChannels * (bitDepth / 8), true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);

      for (let i = 0; i < interleaved.length; i++) {
        const sample = Math.max(-1, Math.min(1, interleaved[i]));
        view.setInt16(44 + i * 2, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      }

      return wavBuffer;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // ============ API Communication ============
    function getModel() {
      return webSearchEnabled ? MODEL_ONLINE : MODEL;
    }

    function buildSystemPrompt() {
      const today = new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      return `You are a voice assistant. Today is ${today}. You receive audio from the user's microphone and respond with spoken output.

IMPORTANT: First transcribe what the user said using [USER]...[/USER] tags at the start of your response. This is required for the system to work. Example:

[USER]
What's the weather like?
[/USER]

Your response goes here...

Your responses will be converted to speech, so:
- Be concise and conversational
- Avoid lists, bullet points, or complex formatting
- Don't use special characters or symbols that don't speak well
- For numbers, acronyms, or technical terms that might be mispronounced, add a pronunciation hint in double brackets immediately after: "API [[A P I]]" or "$50 [[fifty dollars]]"
- Keep responses focused and to the point

Respond naturally as if having a spoken conversation.`;
    }

    async function sendAudioToAPI(base64Audio) {
      const requestStartTime = performance.now();
      shouldStopSpeaking = false;
      speechQueue = [];

      try {
        const response = await fetch(`${OPENROUTER_API_URL}/chat/completions`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': window.location.origin,
            'X-Title': 'Shy'
          },
          body: JSON.stringify({
            model: getModel(),
            stream: true,
            messages: [
              { role: 'system', content: buildSystemPrompt() },
              ...conversationHistory,
              {
                role: 'user',
                content: [
                  { type: 'text', text: 'Listen to this audio and respond.' },
                  { type: 'input_audio', input_audio: { data: base64Audio, format: 'wav' } }
                ]
              }
            ],
            provider: {
              only: ['google-vertex'],
              allow_fallbacks: false,
              zdr: true
            }
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'API request failed');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';
        let sentenceBuffer = '';
        let buffer = '';
        let usage = null;
        let userTranscript = null;
        let transcriptExtracted = false;

        setButtonState('speaking');
        searchToggle.classList.add('hidden');
        stopBtn.classList.remove('hidden');

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine || !trimmedLine.startsWith('data: ')) continue;

            const data = trimmedLine.slice(6);
            if (data === '[DONE]') continue;

            try {
              const parsed = JSON.parse(data);
              if (parsed.usage) usage = parsed.usage;

              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                fullResponse += content;

                // Extract user transcript
                if (!transcriptExtracted) {
                  const match = fullResponse.match(/\[USER\]\s*([\s\S]*?)\s*\[\/USER\]/);
                  if (match) {
                    userTranscript = match[1].trim();
                    transcriptExtracted = true;
                  }
                }

                // Queue speech for response (after transcript extraction)
                if (transcriptExtracted) {
                  const endTagIndex = fullResponse.indexOf('[/USER]');
                  if (endTagIndex !== -1) {
                    const responseOnly = fullResponse.slice(endTagIndex + 7);
                    const prevResponse = fullResponse.slice(0, -content.length);
                    const prevEndIdx = prevResponse.indexOf('[/USER]');
                    const prevResponseOnly = prevEndIdx !== -1 ? prevResponse.slice(prevEndIdx + 7) : '';

                    if (responseOnly.length > prevResponseOnly.length) {
                      sentenceBuffer += responseOnly.slice(prevResponseOnly.length);
                    }
                  }
                }

                // Speak complete sentences
                const sentenceMatch = sentenceBuffer.match(/^(.*?[.!?])\s*/);
                if (sentenceMatch) {
                  const sentence = sentenceMatch[1];
                  sentenceBuffer = sentenceBuffer.slice(sentenceMatch[0].length);
                  queueSpeech(sentence);
                }
              }
            } catch (e) {}
          }
        }

        // Speak remaining text
        if (sentenceBuffer.trim()) {
          queueSpeech(sentenceBuffer.trim());
        }

        // Update stats from API response
        if (usage && typeof usage.cost === 'number') {
          updateSessionCost(usage.cost);
        }

        // Clean response for history
        let responseOnly = fullResponse;
        const endTagIndex = fullResponse.indexOf('[/USER]');
        if (endTagIndex !== -1) {
          responseOnly = fullResponse.slice(endTagIndex + 7).trim();
        }
        const cleanResponse = stripSpeechHints(responseOnly);

        // Save to conversation history
        conversationHistory.push({ role: 'user', content: userTranscript || '[voice message]' });
        conversationHistory.push({ role: 'assistant', content: cleanResponse });
        updateNewChatButton();

      } catch (error) {
        console.error('API error:', error);
        showError(error.message);
        setButtonState('ready');
        searchToggle.classList.remove('hidden');
        stopBtn.classList.add('hidden');
      }
    }

    function buildTextSystemPrompt() {
      const today = new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      return `You are a helpful assistant. Today is ${today}.

Be concise and direct in your responses. Focus on being helpful and informative.`;
    }

    async function sendTextToAPI(userText) {
      if (!userText.trim() || isProcessingText) return;

      // Test feature: NNNw generates NNN words on a random topic
      const wordMatch = userText.trim().match(/^(\d+)w$/);
      if (wordMatch) {
        const wordCount = parseInt(wordMatch[1], 10);
        userText = `Write exactly ${wordCount} words on a random interesting topic. Pick something unexpected and engaging.`;
      }

      isProcessingText = true;
      textSendBtn.classList.add('loading');
      textInput.disabled = true;
      stopBtn.classList.remove('hidden');
      searchToggle.classList.add('hidden');

      // Add user message to UI
      addMessageToHistory('user', userText);

      // Start streaming response
      addMessageToHistory('assistant', '', true);

      try {
        const response = await fetch(`${OPENROUTER_API_URL}/chat/completions`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': window.location.origin,
            'X-Title': 'Shy'
          },
          body: JSON.stringify({
            model: getModel(),
            stream: true,
            messages: [
              { role: 'system', content: buildTextSystemPrompt() },
              ...conversationHistory,
              { role: 'user', content: userText }
            ],
            provider: {
              only: ['google-vertex'],
              allow_fallbacks: false,
              zdr: true
            }
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'API request failed');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';
        let buffer = '';
        let usage = null;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine || !trimmedLine.startsWith('data: ')) continue;

            const data = trimmedLine.slice(6);
            if (data === '[DONE]') continue;

            try {
              const parsed = JSON.parse(data);
              if (parsed.usage) usage = parsed.usage;

              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                fullResponse += content;
                updateStreamingMessage(fullResponse);
              }
            } catch (e) {}
          }
        }

        finishStreamingMessage();

        // Update stats
        if (usage && typeof usage.cost === 'number') {
          updateSessionCost(usage.cost);
        }

        // Save to conversation history
        conversationHistory.push({ role: 'user', content: userText });
        conversationHistory.push({ role: 'assistant', content: fullResponse });
        updateNewChatButton();

      } catch (error) {
        console.error('API error:', error);
        showError(error.message);
        finishStreamingMessage();
        // Remove the empty assistant message if we failed
        const lastGroup = conversationHistoryEl.lastElementChild;
        if (lastGroup) {
          const assistantEl = lastGroup.querySelector('.message.assistant');
          if (assistantEl && !assistantEl.textContent) {
            assistantEl.remove();
          }
        }
      } finally {
        isProcessingText = false;
        textSendBtn.classList.remove('loading');
        textInput.disabled = false;
        // Only auto-focus on desktop to avoid keyboard popping up on mobile
        if (window.innerWidth > 600) {
          textInput.focus();
        }
        stopBtn.classList.add('hidden');
        searchToggle.classList.remove('hidden');
      }
    }

    // ============ Text Processing ============
    function stripSpeechHints(text) {
      return text.replace(/\[\[([^\]]+)\]\]/g, '');
    }

    function convertToSpeech(text) {
      const hintRegex = /\[\[([^\]]+)\]\]/g;
      let result = text;
      let match;
      const replacements = [];

      while ((match = hintRegex.exec(result)) !== null) {
        const hint = match[1];
        const hintStart = match.index;
        const hintEnd = hintStart + match[0].length;
        const hintWordCount = hint.trim().split(/\s+/).length;

        const textBefore = result.slice(0, hintStart).trimEnd();
        const wordsBefore = textBefore.split(/\s+/);
        const wordsToReplace = Math.min(hintWordCount, wordsBefore.length);
        const replaceStart = textBefore.length - wordsBefore.slice(-wordsToReplace).join(' ').length;

        replacements.push({ start: replaceStart, end: hintEnd, replacement: hint });
      }

      for (let i = replacements.length - 1; i >= 0; i--) {
        const r = replacements[i];
        result = result.slice(0, r.start) + r.replacement + result.slice(r.end);
      }

      return result;
    }

    function sanitizeForSpeech(text) {
      let result = convertToSpeech(text);
      return result
        .replace(/^#{1,6}\s+/gm, '')
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
        .replace(/https?:\/\/[^\s)]+/g, '')
        .replace(/\*\*([^*]+)\*\*/g, '$1')
        .replace(/\*([^*]+)\*/g, '$1')
        .replace(/__([^_]+)__/g, '$1')
        .replace(/_([^_]+)_/g, '$1')
        .replace(/```[\s\S]*?```/g, '')
        .replace(/`([^`]+)`/g, '$1')
        .replace(/^>\s*/gm, '')
        .replace(/^[-*+]\s+/gm, ', ')
        .replace(/^\d+\.\s+/gm, ', ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    // ============ Text-to-Speech ============
    function queueSpeech(text) {
      if (!text.trim() || shouldStopSpeaking) return;
      const sanitized = sanitizeForSpeech(text);
      if (!sanitized) return;
      speechQueue.push(sanitized);
      if (!isSpeaking) processQueue();
    }

    function processQueue() {
      if (shouldStopSpeaking || speechQueue.length === 0) {
        isSpeaking = false;
        if (speechQueue.length === 0) {
          setButtonState('ready');
          searchToggle.classList.remove('hidden');
          stopBtn.classList.add('hidden');
        }
        return;
      }

      isSpeaking = true;
      const text = speechQueue.shift();

      if (!window.speechSynthesis) {
        processQueue();
        return;
      }

      // iOS Safari workaround: cancel any pending speech first
      speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1;
      utterance.pitch = 1;
      utterance.volume = 1;

      // Select voice
      const voices = speechSynthesis.getVoices();
      let voice = null;

      if (selectedVoiceName) {
        voice = voices.find(v => v.name === selectedVoiceName);
      }

      // Fallback to default voice if selected not found
      if (!voice) {
        voice = getDefaultVoice(voices);
      }

      if (voice) {
        utterance.voice = voice;
      }

      // iOS Safari fix: onend often doesn't fire, use timeout as fallback
      let ended = false;
      const markEnded = () => {
        if (ended) return;
        ended = true;
        processQueue();
      };

      utterance.onend = markEnded;
      utterance.onerror = markEnded;

      // Fallback timeout for iOS - estimate ~80ms per character at normal rate
      const estimatedDuration = Math.max(2000, text.length * 80);
      setTimeout(() => {
        if (!ended && isSpeaking) {
          console.warn('Speech timeout fallback triggered');
          markEnded();
        }
      }, estimatedDuration);

      // iOS Safari: need to resume in case it's paused
      speechSynthesis.resume();
      speechSynthesis.speak(utterance);
    }

    function stopSpeaking() {
      shouldStopSpeaking = true;
      speechQueue = [];
      speechSynthesis.cancel();
      isSpeaking = false;
      setButtonState('ready');
      searchToggle.classList.remove('hidden');
      stopBtn.classList.add('hidden');
    }

    // ============ Voice Settings ============
    function isCloudVoice(voice) {
      return voice.localService === false;
    }

    // Recommended voices - high quality on-device voices
    const recommendedVoices = [
      'Samantha (Enhanced)', 'Ava (Premium)', 'Zoe (Premium)', 'Tom (Enhanced)',
      'Serena (Premium)', 'Daniel (Enhanced)', 'Karen (Enhanced)',
      'Google UK English Female', 'Google UK English Male', 'Google US English'
    ];

    function isRecommended(voice) {
      return recommendedVoices.some(name => voice.name.includes(name));
    }

    // Get the default voice using the same logic as processQueue
    function getDefaultVoice(voices) {
      const preferredLocal = [
        'Samantha (Enhanced)', 'Ava (Premium)', 'Zoe (Premium)', 'Tom (Enhanced)',
        'Serena (Premium)', 'Daniel (Enhanced)', 'Karen (Enhanced)', 'Alex',
        'Samantha', 'Daniel', 'Karen', 'Moira', 'Tessa'
      ];

      for (const name of preferredLocal) {
        const voice = voices.find(v => v.name.includes(name) && v.localService !== false);
        if (voice) return voice;
      }

      // Fallback to any English local voice
      let voice = voices.find(v => v.lang.startsWith('en') && v.localService !== false);
      if (voice) return voice;

      // Last resort: any English voice
      return voices.find(v => v.lang.startsWith('en'));
    }

    // Initialize default voice at startup
    function initDefaultVoice() {
      if (selectedVoiceName) return; // Already have a selection

      const voices = speechSynthesis.getVoices();
      const englishVoices = voices.filter(v => v.lang.startsWith('en'));
      if (englishVoices.length === 0) return;

      const defaultVoice = getDefaultVoice(englishVoices);
      if (defaultVoice) {
        selectedVoiceName = defaultVoice.name;
        localStorage.setItem('selectedVoice', defaultVoice.name);
      }
    }

    function populateVoiceList() {
      const voices = speechSynthesis.getVoices();
      let englishVoices = voices.filter(v => v.lang.startsWith('en'));

      // Ensure we have a default voice selected
      initDefaultVoice();

      // Filter out cloud voices if toggle is off
      if (!cloudVoicesEnabled) {
        englishVoices = englishVoices.filter(v => !isCloudVoice(v));
      }

      // Check if any cloud voices exist
      const allVoices = speechSynthesis.getVoices();
      const hasCloudVoices = allVoices.some(v => v.lang.startsWith('en') && isCloudVoice(v));

      // Sort: Recommended first, then Cloud (if enabled), then Premium/Enhanced, then alphabetical
      englishVoices.sort((a, b) => {
        const aRec = isRecommended(a);
        const bRec = isRecommended(b);
        // Recommended voices at the very top
        if (aRec && !bRec) return -1;
        if (!aRec && bRec) return 1;
        const aCloud = isCloudVoice(a);
        const bCloud = isCloudVoice(b);
        // Cloud voices next when enabled
        if (aCloud && !bCloud) return -1;
        if (!aCloud && bCloud) return 1;
        const aPremium = a.name.includes('Premium') || a.name.includes('Enhanced');
        const bPremium = b.name.includes('Premium') || b.name.includes('Enhanced');
        if (aPremium && !bPremium) return -1;
        if (!aPremium && bPremium) return 1;
        return a.name.localeCompare(b.name);
      });

      voiceList.innerHTML = '';

      // Update toggle state and visibility
      const toggle = document.getElementById('cloudVoicesToggle');
      const toggleContainer = document.querySelector('.cloud-toggle');
      if (toggle) toggle.checked = cloudVoicesEnabled;
      if (toggleContainer) toggleContainer.style.display = hasCloudVoices ? '' : 'none';

      // Update current voice display
      const currentVoiceEl = document.getElementById('currentVoiceName');
      if (currentVoiceEl) {
        currentVoiceEl.textContent = selectedVoiceName || 'None selected';
      }

      englishVoices.forEach(voice => {
        const isSelected = selectedVoiceName === voice.name;
        const isCloud = isCloudVoice(voice);
        const isRec = isRecommended(voice);
        const item = document.createElement('div');
        item.className = `voice-item${isSelected ? ' selected' : ''}`;
        item.dataset.voiceName = voice.name;

        let badges = '';
        if (isRec) badges += '<span class="voice-recommended-badge">recommended</span>';
        if (isCloud) badges += '<span class="voice-cloud-badge">cloud</span>';

        item.innerHTML = `
          <div class="voice-radio"></div>
          <div class="voice-info">
            <div class="voice-name">${voice.name}${badges}</div>
            <div class="voice-lang">${voice.lang}</div>
          </div>
          <button class="voice-preview">Preview</button>
        `;

        item.addEventListener('click', (e) => {
          if (e.target.classList.contains('voice-preview')) return;
          selectVoice(voice.name);
        });

        item.querySelector('.voice-preview').addEventListener('click', (e) => {
          e.stopPropagation();
          previewVoice(voice);
        });

        voiceList.appendChild(item);
      });
    }

    function selectVoice(voiceName) {
      selectedVoiceName = voiceName;
      localStorage.setItem('selectedVoice', voiceName);
      document.querySelectorAll('.voice-item').forEach(item => {
        const name = item.dataset.voiceName;
        item.classList.toggle('selected', name === voiceName);
      });
      // Update current voice display
      const currentVoiceEl = document.getElementById('currentVoiceName');
      if (currentVoiceEl) {
        currentVoiceEl.textContent = voiceName;
      }
    }

    function previewVoice(voice) {
      speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance("Hello! I'm your voice assistant.");
      utterance.voice = voice;
      speechSynthesis.speak(utterance);
    }

    function openVoiceSettings() {
      populateVoiceList();
      voiceModal.classList.remove('hidden');
    }

    function closeVoiceSettings() {
      speechSynthesis.cancel();
      voiceModal.classList.add('hidden');
    }

    // ============ Event Listeners ============
    function setupEventListeners() {
      loginBtn.addEventListener('click', startOAuthFlow);
      logoutBtn.addEventListener('click', () => {
        settingsDropdown.classList.remove('open');
        logout();
      });

      // Main button click
      mainButton.addEventListener('click', () => {
        if (isSpeaking || speechQueue.length > 0) {
          stopSpeaking();
        }
        if (isListening) {
          stopRecording();
        } else {
          startRecording();
        }
      });

      // Spacebar
      document.addEventListener('keydown', (e) => {
        if (!voiceModal.classList.contains('hidden')) return;
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (!apiKey) return;

        if (e.code === 'Space') {
          e.preventDefault();
          if (isSpeaking || speechQueue.length > 0) {
            stopSpeaking();
          }
          if (isListening) {
            stopRecording();
          } else {
            startRecording();
          }
        }
      });

      // Settings dropdown menu
      settingsMenuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        settingsDropdown.classList.toggle('open');
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!settingsDropdown.contains(e.target) && e.target !== settingsMenuBtn) {
          settingsDropdown.classList.remove('open');
        }
      });

      // Voice settings from dropdown
      voiceSettingsBtn.addEventListener('click', () => {
        settingsDropdown.classList.remove('open');
        openVoiceSettings();
      });

      // Cost settings from dropdown
      costSettingsBtn.addEventListener('click', openCostModal);

      // Copy chat
      copyChatBtn.addEventListener('click', copyChat);

      // Cost modal
      costModalClose.addEventListener('click', closeCostModal);
      costModal.addEventListener('click', (e) => {
        if (e.target === costModal) closeCostModal();
      });

      // Search toggle
      searchToggle.addEventListener('click', () => {
        webSearchEnabled = !webSearchEnabled;
        localStorage.setItem('webSearchEnabled', webSearchEnabled);
        updateSearchToggleUI();
      });

      // Stop button
      stopBtn.addEventListener('click', stopSpeaking);

      // Voice modal
      modalClose.addEventListener('click', closeVoiceSettings);
      voiceModal.addEventListener('click', (e) => {
        if (e.target === voiceModal) closeVoiceSettings();
      });

      // Voice help toggle
      document.getElementById('voiceHelpBtn').addEventListener('click', () => {
        document.getElementById('voiceHelpContent').classList.toggle('hidden');
      });

      // Cloud voices toggle
      document.getElementById('cloudVoicesToggle').addEventListener('change', (e) => {
        cloudVoicesEnabled = e.target.checked;
        localStorage.setItem('cloudVoicesEnabled', cloudVoicesEnabled);
        // If turning off cloud voices and current selection is a cloud voice, clear it
        if (!cloudVoicesEnabled && selectedVoiceName) {
          const voices = speechSynthesis.getVoices();
          const currentVoice = voices.find(v => v.name === selectedVoiceName);
          if (currentVoice && isCloudVoice(currentVoice)) {
            selectedVoiceName = null;
            localStorage.removeItem('selectedVoice');
          }
        }
        populateVoiceList();
      });

      // Load voices and init default at startup
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = () => {
          speechSynthesis.getVoices();
          initDefaultVoice();
        };
      }
      // Also try immediately in case voices are already loaded
      initDefaultVoice();

      // Mode switching
      voiceModeBtn.addEventListener('click', () => setTextMode(false));
      textModeBtn.addEventListener('click', () => setTextMode(true));

      // New chat
      newChatBtn.addEventListener('click', startNewChat);

      // Text input handling
      textInput.addEventListener('input', () => {
        // Auto-resize textarea
        textInput.style.height = 'auto';
        textInput.style.height = Math.min(textInput.scrollHeight, 160) + 'px';

        // Update send button state
        textSendBtn.classList.toggle('active', textInput.value.trim().length > 0);
      });

      textInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          submitTextMessage();
        }
      });

      textSendBtn.addEventListener('click', submitTextMessage);

      function submitTextMessage() {
        const text = textInput.value.trim();
        if (text && !isProcessingText) {
          textInput.value = '';
          textInput.style.height = 'auto';
          textSendBtn.classList.remove('active');
          textInput.blur(); // Hide keyboard on mobile
          sendTextToAPI(text);
        }
      }

      // Mobile keyboard handling - keep input above virtual keyboard
      if (window.visualViewport) {
        const baseBottom = 88; // 5.5rem in pixels

        function adjustForKeyboard() {
          const viewport = window.visualViewport;
          const keyboardHeight = window.innerHeight - viewport.height - viewport.offsetTop;

          if (keyboardHeight > 100) {
            // Keyboard is open
            textInputContainer.style.bottom = (keyboardHeight + 12) + 'px';
          } else {
            // Keyboard is closed
            textInputContainer.style.bottom = '';
          }
        }

        window.visualViewport.addEventListener('resize', adjustForKeyboard);
        window.visualViewport.addEventListener('scroll', adjustForKeyboard);
      }

    }

    // ============ Start ============
    init();
  </script>
</body>
</html>
