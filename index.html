<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="screen-orientation" content="portrait">
  <title>Spraff</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='22' fill='%234F46E5'/><text x='50' y='68' text-anchor='middle' font-family='system-ui' font-size='50' font-weight='900' fill='white'>S</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,400;12..96,700;12..96,800&family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #FAFAFA;
      --bg-warm: #F0F0F5;
      --fg: #1a1a2e;
      --fg-muted: #64648C;
      --accent: #4F46E5;
      --accent-dark: #3730A3;
      --surface: #ffffff;
      --surface-hover: #F5F5FF;
      --border: #E0E0EC;
      --listening: #4F46E5;
      --success: #10B981;
      --link: #4F46E5;
      --secondary: #F97316;
      --accent-light: #EEF2FF;
      --shadow-sm: 0 2px 8px rgba(79, 70, 229, 0.12);
      --shadow-md: 0 8px 24px rgba(79, 70, 229, 0.18);
      --shadow-lg: 0 16px 48px rgba(79, 70, 229, 0.22);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    /* Remove focus outlines globally, use custom focus styles instead */
    *:focus {
      outline: none;
    }

    /* Accessible focus for keyboard navigation */
    *:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    /* Remove focus-visible on touch devices */
    @media (hover: none) and (pointer: coarse) {
      *:focus-visible {
        outline: none;
      }
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--fg);
      font-weight: 500;
    }

    /* Login Screen */
    .login-screen {
      position: fixed;
      inset: 0;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.6s ease-out;
      background:
        radial-gradient(ellipse 80% 50% at 50% -20%, rgba(79, 70, 229, 0.15), transparent),
        var(--bg);
    }

    .login-screen.hidden {
      display: none;
    }

    .logo {
      margin-bottom: 1rem;
      opacity: 1;
      animation: logoFloat 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      filter: drop-shadow(0 20px 40px rgba(79, 70, 229, 0.3));
    }

    @keyframes logoFloat {
      0% { transform: translateY(30px) scale(0.8); opacity: 0; }
      100% { transform: translateY(0) scale(1); opacity: 1; }
    }

    .login-tagline {
      font-family: 'Outfit', sans-serif;
      color: var(--fg-muted);
      font-size: 1.05rem;
      font-weight: 400;
      letter-spacing: 0.02em;
      margin-bottom: 3rem;
      opacity: 0;
      animation: taglineFade 0.6s ease-out 0.3s forwards;
    }

    @keyframes taglineFade {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    .login-btn {
      position: relative;
      background: var(--fg);
      color: white;
      border: none;
      padding: 1rem 1.75rem;
      padding-right: 3.5rem;
      font-family: 'Outfit', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 100px;
      box-shadow: 0 4px 20px rgba(26, 26, 46, 0.25);
      opacity: 0;
      animation: btnAppear 0.5s ease-out 0.5s forwards;
      overflow: hidden;
    }

    .login-btn::before {
      content: '';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      background: var(--accent);
      border-radius: 50%;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .login-btn::after {
      content: '';
      position: absolute;
      right: 1.55rem;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 8px;
      border-right: 2px solid white;
      border-top: 2px solid white;
      transform: translateY(-50%) rotate(45deg);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes btnAppear {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    .login-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(26, 26, 46, 0.35);
      background: var(--accent);
    }

    .login-btn:hover::before {
      background: white;
      transform: translateY(-50%) scale(1.1);
    }

    .login-btn:hover::after {
      border-color: var(--accent);
      right: 1.45rem;
    }

    .login-btn:active {
      transform: translateY(0) scale(0.98);
    }

    .login-about {
      margin-top: 1.5rem;
      font-family: 'Outfit', sans-serif;
      font-size: 0.9rem;
      color: var(--fg-muted);
      text-decoration: underline;
      transition: color 0.2s ease;
      opacity: 0;
      animation: btnAppear 0.5s ease-out 0.5s forwards;
    }

    .login-about:hover {
      color: var(--accent);
    }

    /* Main Voice Screen */
    .voice-screen {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .voice-screen.hidden {
      display: none;
    }

    .voice-screen.text-mode::before {
      content: '';
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 180px;
      background: linear-gradient(to bottom, transparent, var(--bg) 70%);
      pointer-events: none;
      z-index: 40;
    }

    .voice-screen.text-mode::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(to top, transparent, var(--bg) 70%);
      pointer-events: none;
      z-index: 40;
    }

    /* The Button - Central Control */
    .button-container {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .main-button {
      width: 100px;
      height: 100px;
      border-radius: 28px;
      border: none;
      background: var(--accent);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-lg), 0 0 0 0 var(--accent-light);
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }

    .main-button:hover {
      transform: scale(1.08);
      box-shadow: var(--shadow-lg), 0 0 0 6px var(--accent-light);
      background: var(--accent-dark);
    }

    .main-button:active {
      transform: scale(0.95);
    }

    .main-button svg {
      width: 40px;
      height: 40px;
      stroke: white;
      stroke-width: 2.5;
      fill: none;
      transition: all 0.2s ease;
    }

    .main-button .stop-icon {
      display: none;
    }

    .main-button .spinner-icon {
      display: none;
      width: 36px;
      height: 36px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    /* Button States */
    .main-button.listening {
      background: var(--secondary);
      box-shadow: 0 8px 32px rgba(249, 115, 22, 0.4), 0 0 0 6px rgba(249, 115, 22, 0.15);
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.06); }
    }

    .main-button.listening .mic-icon {
      display: none;
    }

    .main-button.listening .stop-icon {
      display: block;
    }

    .main-button.processing {
      opacity: 0.9;
      cursor: wait;
    }

    .main-button.processing .mic-icon,
    .main-button.processing .stop-icon {
      display: none;
    }

    .main-button.processing .spinner-icon {
      display: block;
    }

    .main-button.speaking {
      background: var(--secondary);
      box-shadow: 0 8px 32px rgba(249, 115, 22, 0.4);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Status Text */
    .status-text {
      position: absolute;
      bottom: -55px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--fg-muted);
      white-space: nowrap;
      transition: all 0.3s ease;
    }

    .status-text.listening {
      color: var(--secondary);
    }

    .status-text.speaking {
      color: var(--secondary);
    }

    /* Upload progress bar */
    .upload-progress {
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .upload-progress.visible {
      opacity: 1;
    }

    .upload-progress-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      width: 0%;
      transition: width 0.15s ease;
    }

    .upload-progress.speaking .upload-progress-bar {
      background: var(--secondary);
    }

    /* Hint text below button */
    .hint-text {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Outfit', sans-serif;
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--fg-muted);
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .hint-text.hidden {
      opacity: 0;
    }

    .hint-text kbd {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 0.8rem;
      font-weight: 700;
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 8px;
      margin: 0 0.2rem;
      box-shadow: var(--shadow-sm);
    }

    /* Bottom Controls */
    .bottom-controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 0.6rem;
      z-index: 50;
    }

    .control-pill {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.65rem 1rem;
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--fg-muted);
      box-shadow: var(--shadow-sm);
    }

    .control-pill:hover {
      border-color: var(--accent);
      color: var(--accent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .control-pill.active {
      border-color: var(--accent);
      background: var(--accent-light);
      color: var(--accent);
    }

    .control-pill svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      stroke-width: 2;
      fill: none;
    }

    .control-pill.hidden {
      display: none;
    }

    /* Search pill - show on/off state clearly */
    .search-pill .status-indicator {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    .search-pill.active .status-indicator {
      opacity: 1;
    }

    .search-pill .search-label-short {
      display: none;
    }

    /* Stop button special styling */
    .stop-pill {
      border-color: var(--secondary);
      color: var(--secondary);
      background: rgba(249, 115, 22, 0.1);
    }

    .stop-pill:hover {
      background: rgba(249, 115, 22, 0.2);
      border-color: var(--secondary);
      color: var(--secondary);
    }

    /* New chat button - top left, aligned with content */
    .new-chat-btn {
      position: fixed;
      top: 1.5rem;
      left: max(1.5rem, calc(50% - 360px));
      width: 44px;
      height: 44px;
      border-radius: 14px;
      border: 2px solid var(--border);
      background: var(--surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 100;
      box-shadow: var(--shadow-sm);
    }

    .new-chat-btn:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .new-chat-btn svg {
      width: 20px;
      height: 20px;
      stroke: var(--fg-muted);
      stroke-width: 2.5;
      fill: none;
    }

    .new-chat-btn:hover svg {
      stroke: var(--accent);
    }

    .new-chat-btn.hidden {
      display: none;
    }

    /* Settings menu - top right, aligned with content */
    .settings-menu {
      position: fixed;
      top: 1.5rem;
      right: max(1.5rem, calc(50% - 360px));
      z-index: 100;
    }

    .settings-menu.hidden {
      display: none;
    }

    .settings-menu-btn {
      padding: 0.6rem 1rem;
      border-radius: 14px;
      border: 2px solid var(--border);
      background: var(--surface);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      transition: all 0.2s ease;
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--fg);
      box-shadow: var(--shadow-sm);
    }

    .settings-menu-btn:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .settings-menu-btn:focus {
      outline: none;
    }

    /* Settings dropdown */
    .settings-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 0.5rem;
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow-lg);
      min-width: 180px;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px) scale(0.95);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 0.5rem;
    }

    .settings-dropdown.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    .settings-dropdown button {
      width: 100%;
      padding: 0.85rem 1rem;
      background: none;
      border: none;
      font-family: 'Outfit', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0;
      color: var(--fg);
      text-align: left;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.7rem;
      transition: all 0.15s ease;
      border-radius: 12px;
    }

    .settings-dropdown button:hover {
      background: var(--accent-light);
      color: var(--accent);
    }

    .settings-dropdown button svg {
      width: 18px;
      height: 18px;
      stroke: var(--fg-muted);
      stroke-width: 2;
      fill: none;
    }

    .settings-dropdown .divider {
      height: 2px;
      background: var(--border);
    }

    /* Cost Modal */
    .modal-small {
      max-width: 340px;
    }

    .cost-stats {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .cost-stat {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .cost-stat-label {
      font-family: 'Outfit', sans-serif;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--fg-muted);
    }

    .cost-stat-value {
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--fg);
      font-variant-numeric: tabular-nums;
    }

    /* Voice Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(26, 26, 46, 0.4);
      backdrop-filter: blur(12px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }

    .modal-overlay.hidden {
      display: none;
    }

    .modal {
      background: var(--surface);
      border-radius: 24px;
      border: 2px solid var(--border);
      width: 100%;
      max-width: 460px;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-lg);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1.25rem 1.5rem;
      border-bottom: 2px solid var(--border);
    }

    .modal-header h3 {
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 1rem;
      font-weight: 800;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--fg);
    }

    .modal-close {
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 10px;
      width: 36px;
      height: 36px;
      font-size: 1.3rem;
      color: var(--fg-muted);
      cursor: pointer;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
    }

    .modal-close:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .modal-body {
      padding: 1.25rem;
      overflow-y: auto;
    }

    .voice-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .voice-item {
      display: flex;
      align-items: center;
      gap: 0.85rem;
      padding: 0.9rem 1.1rem;
      background: var(--bg);
      border: 2px solid transparent;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .voice-item:hover {
      background: var(--bg-warm);
      transform: translateX(4px);
      border-color: var(--border);
    }

    .voice-item.selected {
      border-color: var(--accent);
      background: var(--accent-light);
    }

    .voice-radio {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .voice-item.selected .voice-radio {
      border-color: var(--accent);
    }

    .voice-item.selected .voice-radio::after {
      content: '';
      width: 10px;
      height: 10px;
      background: var(--accent);
      border-radius: 50%;
    }

    .voice-info {
      flex: 1;
      min-width: 0;
    }

    .voice-name {
      font-family: 'Outfit', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--fg);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .voice-lang {
      font-family: 'Outfit', sans-serif;
      font-size: 0.8rem;
      color: var(--fg-muted);
      margin-top: 0.15rem;
    }

    .voice-preview {
      background: var(--surface);
      border: 2px solid var(--border);
      color: var(--fg-muted);
      padding: 0.5rem 0.9rem;
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 0.8rem;
      font-weight: 700;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .voice-preview:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-light);
    }

    .voice-cloud-badge,
    .voice-recommended-badge {
      font-size: 0.7rem;
      font-weight: 700;
      color: var(--fg-muted);
      background: var(--bg);
      padding: 0.2rem 0.5rem;
      border-radius: 6px;
      margin-left: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .voice-recommended-badge {
      color: var(--success);
      background: rgba(16, 185, 129, 0.15);
    }

    /* Voice help */
    .voice-help {
      padding: 0 0.5rem 1rem;
    }

    .voice-help-btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: none;
      border: none;
      font-family: 'Outfit', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--link);
      cursor: pointer;
      padding: 0;
    }

    .voice-help-btn:hover {
      text-decoration: underline;
    }

    .voice-help-content {
      margin-top: 0.75rem;
      padding: 1rem;
      background: var(--bg);
      border-radius: 12px;
      border: 2px solid var(--border);
      font-family: 'Outfit', sans-serif;
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--fg-muted);
    }

    .voice-help-content.hidden {
      display: none;
    }

    .voice-help-content p {
      margin: 0 0 0.6rem;
    }

    .voice-help-content p:last-child {
      margin-bottom: 0;
    }

    .voice-help-content strong {
      color: var(--fg);
      font-weight: 700;
    }

    /* Current voice display */
    .current-voice {
      padding: 0.9rem 1rem;
      margin: 0 0.5rem 1rem;
      background: var(--bg);
      border-radius: 12px;
      border: 2px solid var(--border);
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .current-voice-label {
      font-family: 'Bricolage Grotesque', sans-serif;
      font-size: 0.8rem;
      font-weight: 700;
      color: var(--fg-muted);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .current-voice-name {
      font-family: 'Outfit', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--fg);
    }

    /* Cloud toggle */
    .cloud-toggle {
      padding: 0 0.5rem 1rem;
      border-bottom: 2px solid var(--border);
      margin-bottom: 1rem;
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      gap: 1rem;
    }

    .toggle-label {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .toggle-title {
      font-family: 'Outfit', sans-serif;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--fg);
    }

    .toggle-desc {
      font-family: 'Outfit', sans-serif;
      font-size: 0.85rem;
      color: var(--fg-muted);
    }

    .toggle-row input {
      display: none;
    }

    .toggle-switch {
      width: 48px;
      height: 28px;
      background: var(--border);
      border-radius: 14px;
      position: relative;
      transition: background 0.2s ease;
      flex-shrink: 0;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      background: var(--surface);
      border-radius: 50%;
      transition: transform 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .toggle-row input:checked + .toggle-switch {
      background: var(--accent);
    }

    .toggle-row input:checked + .toggle-switch::after {
      transform: translateX(20px);
    }

    /* Error Toast */
    .error-toast {
      position: fixed;
      bottom: 6rem;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--accent-light);
      border: 3px solid var(--accent);
      padding: 1rem 1.75rem;
      font-family: 'Outfit', sans-serif;
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent);
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 200;
      border-radius: 16px;
      box-shadow: var(--shadow-lg);
      pointer-events: none;
    }

    .error-toast.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Conversation History */
    .conversation-history {
      position: fixed;
      inset: 0;
      overflow-y: auto;
      padding: 5.5rem 1.5rem 12rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      z-index: 1;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      -webkit-overflow-scrolling: touch;
    }

    .conversation-history.visible {
      opacity: 1;
      visibility: visible;
    }

    .conversation-history::-webkit-scrollbar {
      width: 4px;
    }

    .conversation-history::-webkit-scrollbar-track {
      background: transparent;
    }

    .conversation-history::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .message-group {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      max-width: 720px;
      width: 100%;
      margin: 0 auto;
    }

    .message {
      font-family: 'Outfit', sans-serif;
      font-size: 1.05rem;
      line-height: 1.65;
      animation: messageIn 0.3s ease-out;
      max-width: 85%;
    }

    @keyframes messageIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.user {
      color: var(--fg);
      background: var(--accent-light);
      padding: 1.1rem 1.4rem;
      border-radius: 20px 20px 6px 20px;
      border: 2px solid var(--accent);
      align-self: flex-end;
      margin-left: auto;
      font-weight: 500;
    }

    .message.assistant {
      color: var(--fg);
      align-self: flex-start;
      margin-right: auto;
      padding-left: 0.5rem;
    }

    .message.assistant h1,
    .message.assistant h2,
    .message.assistant h3,
    .message.assistant h4 {
      font-family: 'Bricolage Grotesque', sans-serif;
      font-weight: 700;
      margin: 0.75em 0 0.25em;
      line-height: 1.3;
    }

    .message.assistant h1:first-child,
    .message.assistant h2:first-child,
    .message.assistant h3:first-child {
      margin-top: 0;
    }

    .message.assistant h1 { font-size: 1.5em; }
    .message.assistant h2 { font-size: 1.3em; }
    .message.assistant h3 { font-size: 1.15em; }
    .message.assistant h4 { font-size: 1.05em; }

    .message.assistant p {
      margin: 0.5em 0;
    }

    .message.assistant p:first-child {
      margin-top: 0;
    }

    .message.assistant p:last-child {
      margin-bottom: 0;
    }

    .message.assistant ul,
    .message.assistant ol {
      margin: 0.5em 0;
      padding-left: 1.5em;
      margin-left: 0.5em;
    }

    .message.assistant li {
      margin: 0.25em 0;
    }

    .message.assistant code {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.88em;
      background: var(--bg-warm);
      padding: 0.2em 0.4em;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .message.assistant pre {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 0.85em;
      background: var(--bg-warm);
      padding: 1em 1.25em;
      border-radius: 12px;
      border: 2px solid var(--border);
      overflow-x: auto;
      margin: 0.75em 0;
      white-space: pre;
    }

    .message.assistant pre code {
      background: none;
      padding: 0;
      border: none;
    }

    .message.assistant a {
      color: var(--link);
      text-decoration: none;
      font-weight: 600;
    }

    .message.assistant a:hover {
      text-decoration: underline;
    }

    .message.assistant strong {
      font-weight: 700;
    }

    .message.assistant em {
      font-style: italic;
    }

    .message.assistant blockquote {
      border-left: 4px solid var(--accent);
      margin: 0.75em 0;
      padding-left: 1.25em;
      color: var(--fg-muted);
      background: var(--accent-light);
      padding: 0.75em 1em 0.75em 1.25em;
      border-radius: 0 12px 12px 0;
    }

    .message.assistant hr {
      border: none;
      border-top: 2px solid var(--border);
      margin: 1.25em 0;
    }

    .message.assistant .table-wrapper {
      overflow-x: auto;
      margin: 0.75em 0;
    }

    .message.assistant table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.95em;
      min-width: max-content;
    }

    .message.assistant th,
    .message.assistant td {
      border: 2px solid var(--border);
      padding: 0.6em 0.9em;
      text-align: left;
    }

    .message.assistant th {
      background: var(--bg-warm);
      font-weight: 700;
    }

    .message.assistant tr:nth-child(even) {
      background: rgba(0, 0, 0, 0.02);
    }

    .message.streaming::after {
      content: '▊';
      animation: blink 0.8s steps(2) infinite;
      color: var(--secondary);
      margin-left: 2px;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Text Input Mode */
    .text-input-container {
      position: fixed;
      bottom: 5.5rem;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 3rem);
      max-width: 580px;
      display: none;
      z-index: 50;
      transition: bottom 0.15s ease-out;
    }

    .text-input-container.visible {
      display: block;
    }

    .text-input-wrapper {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--surface);
      border: 3px solid var(--border);
      border-radius: 20px;
      box-shadow: var(--shadow-md);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 8px;
      padding-left: 0;
    }

    .text-input-wrapper:focus-within {
      border-color: var(--accent);
      box-shadow: var(--shadow-lg), 0 0 0 4px var(--accent-light);
    }

    .text-input {
      flex: 1;
      min-height: 40px;
      max-height: 160px;
      padding: 10px 0 10px 1.25rem;
      font-family: 'Outfit', sans-serif;
      font-size: 1.05rem;
      font-weight: 500;
      line-height: 1.4;
      color: var(--fg);
      background: transparent;
      border: none;
      resize: none;
      outline: none;
      field-sizing: content;
      overflow-y: auto;
      scrollbar-width: none;
    }

    .text-input::-webkit-scrollbar {
      display: none;
    }

    .text-input::placeholder {
      color: var(--fg-muted);
      opacity: 0.7;
    }

    .text-send-btn {
      flex-shrink: 0;
      width: 46px;
      height: 46px;
      border-radius: 14px;
      border: none;
      background: var(--border);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .text-send-btn:hover {
      transform: scale(1.05);
      background: var(--fg-muted);
    }

    .text-send-btn.active {
      background: var(--accent);
      box-shadow: var(--shadow-md);
    }

    .text-send-btn.active:hover {
      transform: scale(1.08);
      background: var(--accent-dark);
      box-shadow: var(--shadow-lg);
    }

    .text-send-btn svg {
      width: 20px;
      height: 20px;
      stroke: white;
      stroke-width: 2.5;
      fill: none;
    }

    .text-send-btn .spinner-icon {
      display: none;
      width: 18px;
      height: 18px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .text-send-btn.loading svg {
      display: none;
    }

    .text-send-btn.loading .spinner-icon {
      display: block;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.35rem;
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow-sm);
      cursor: pointer;
    }

    .mode-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 38px;
      height: 32px;
      border: none;
      background: transparent;
      border-radius: 10px;
      pointer-events: none;
      transition: all 0.2s ease;
    }

    .mode-btn svg {
      width: 18px;
      height: 18px;
      stroke: var(--fg-muted);
      stroke-width: 2;
      fill: none;
      transition: stroke 0.2s ease;
    }

    .mode-btn:hover svg {
      stroke: var(--fg);
    }

    .mode-btn.active {
      background: var(--accent);
    }

    .mode-btn.active svg {
      stroke: white;
    }

    /* Text mode adjustments */
    .voice-screen.text-mode .button-container {
      display: none;
    }

    .voice-screen.text-mode .hint-text {
      display: none;
    }

    /* Ensure cost and menu float above conversation */
    .cost-display {
      z-index: 100;
    }

    /* Mobile */
    @media (max-width: 600px) {
      .main-button {
        width: 88px;
        height: 88px;
        border-radius: 24px;
      }

      .main-button svg {
        width: 36px;
        height: 36px;
      }

      .hint-text {
        display: none;
      }

      .bottom-controls {
        bottom: 1.5rem;
      }

      .cost-display {
        left: 1rem;
        font-size: 0.7rem;
      }

      .settings-menu {
        top: 1rem;
        right: 1rem;
      }

      .new-chat-btn {
        top: 1rem;
        left: 1rem;
        width: 40px;
        height: 40px;
      }

      .text-input-container {
        bottom: 5.5rem;
        width: calc(100% - 2rem);
      }

      .text-input {
        font-size: 16px; /* Prevent iOS zoom */
      }

      .conversation-history {
        padding: 5rem 1rem 10rem;
      }

      .message {
        font-size: 1rem;
      }

      .search-pill .search-label-long {
        display: none;
      }

      .search-pill .search-label-short {
        display: inline;
      }

      .control-pill {
        padding: 0.6rem 0.9rem;
        font-size: 0.75rem;
      }
    }

    /* Landscape orientation warning for mobile */
    .landscape-warning {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 9999;
      background: var(--bg);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      padding: 2rem;
      text-align: center;
    }

    .landscape-warning svg {
      width: 64px;
      height: 64px;
      stroke: var(--accent);
      stroke-width: 1.5;
      fill: none;
      animation: rotatePhone 2s ease-in-out infinite;
    }

    @keyframes rotatePhone {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-15deg); }
      75% { transform: rotate(15deg); }
    }

    .landscape-warning p {
      font-family: 'Outfit', sans-serif;
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--fg-muted);
    }

    @media screen and (max-width: 900px) and (orientation: landscape) and (hover: none) and (pointer: coarse) {
      .landscape-warning {
        display: flex;
      }

      .login-screen,
      .voice-screen {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <!-- Landscape Warning -->
  <div class="landscape-warning">
    <svg viewBox="0 0 24 24">
      <rect x="5" y="2" width="14" height="20" rx="2" ry="2"/>
      <line x1="12" y1="18" x2="12" y2="18.01"/>
    </svg>
    <p>Please rotate your device to portrait mode</p>
  </div>

  <!-- Cost Modal -->
  <div class="modal-overlay hidden" id="costModal">
    <div class="modal modal-small">
      <div class="modal-header">
        <h3>Cost</h3>
        <button class="modal-close" id="costModalClose">&times;</button>
      </div>
      <div class="modal-body">
        <div class="cost-stats">
          <div class="cost-stat">
            <span class="cost-stat-label">OpenRouter balance</span>
            <span class="cost-stat-value" id="costBalance">—</span>
          </div>
          <div class="cost-stat">
            <span class="cost-stat-label">Last message</span>
            <span class="cost-stat-value" id="costLast">—</span>
          </div>
          <div class="cost-stat">
            <span class="cost-stat-label">This session</span>
            <span class="cost-stat-value" id="costSession">$0.00</span>
          </div>
          <div class="cost-stat" id="voiceSizeStat" style="display: none;">
            <span class="cost-stat-label">Last voice message</span>
            <span class="cost-stat-value" id="costVoiceSize">—</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- About Modal -->
  <div class="modal-overlay hidden" id="aboutModal">
    <div class="modal modal-small">
      <div class="modal-header">
        <h3>About</h3>
        <button class="modal-close" id="aboutModalClose">&times;</button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 1rem;">Simple, private AI chat.</p>
        <p style="margin-bottom: 1rem;">
          <a href="https://github.com/martinpllu/spraff" target="_blank" style="color: var(--link); text-decoration: none; font-weight: 600;">GitHub</a>
        </p>
        <p style="color: var(--fg-muted);">
          Created by <a href="https://www.linkedin.com/in/martin-pllu-7034513" target="_blank" style="color: var(--link); text-decoration: none;">Martin Pllu</a>
        </p>
      </div>
    </div>
  </div>

  <!-- Privacy Modal -->
  <div class="modal-overlay hidden" id="privacyModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Privacy Policy</h3>
        <button class="modal-close" id="privacyModalClose">&times;</button>
      </div>
      <div class="modal-body" style="line-height: 1.7;">
        <p style="margin-bottom: 1rem;"><strong>Spraff stores nothing.</strong></p>
        <p style="margin-bottom: 1rem;">This app has no backend. It's a static HTML file that runs entirely in your browser. Your conversations are not stored, logged, or transmitted anywhere except to the AI model provider.</p>
        <p style="margin-bottom: 1rem;"><strong>How your data flows:</strong></p>
        <ul style="margin-bottom: 1rem; padding-left: 1.5rem;">
          <li style="margin-bottom: 0.5rem;"><strong>This app</strong> — No data collection. No analytics. No cookies (except your OpenRouter API key in localStorage).</li>
          <li style="margin-bottom: 0.5rem;"><strong>OpenRouter</strong> — Routes your request to the AI model. With Zero Data Retention models, no conversation content is stored—only metadata (timestamps, token counts).</li>
          <li style="margin-bottom: 0.5rem;"><strong>Google Vertex (Gemini)</strong> — Processes your request with Zero Data Retention enabled. Prompts and responses are not stored or used for training.</li>
        </ul>
        <p style="margin-bottom: 1rem;">When you close the browser tab, your conversation is gone. There's no history, no transcripts, no way to recover what was said.</p>
        <p style="color: var(--fg-muted);">Your OpenRouter API key is stored in your browser's localStorage so you don't have to log in every time. You can clear it by logging out.</p>
      </div>
    </div>
  </div>

  <!-- Voice Settings Modal -->
  <div class="modal-overlay hidden" id="voiceModal">
    <div class="modal">
      <div class="modal-header">
        <h3>Voice Settings</h3>
        <button class="modal-close" id="modalClose">&times;</button>
      </div>
      <div class="modal-body">
        <div class="current-voice" id="currentVoice">
          <span class="current-voice-label">Current:</span>
          <span class="current-voice-name" id="currentVoiceName">None selected</span>
        </div>
        <div class="cloud-toggle">
          <label class="toggle-row">
            <span class="toggle-label">
              <span class="toggle-title">Cloud voices</span>
              <span class="toggle-desc">Higher quality, but text is sent to third party services</span>
            </span>
            <input type="checkbox" id="cloudVoicesToggle">
            <span class="toggle-switch"></span>
          </label>
        </div>
        <div class="voice-help" id="voiceHelp">
          <a class="voice-help-btn" href="https://github.com/martinpllu/spraff#voice-quality" target="_blank">
            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="1.5" fill="none">
              <circle cx="12" cy="12" r="10"/>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
              <line x1="12" y1="17" x2="12.01" y2="17"/>
            </svg>
            How to install better voices
          </a>
        </div>
        <div class="voice-list" id="voiceList"></div>
      </div>
    </div>
  </div>

  <!-- Login Screen -->
  <script>if(location.search.includes('code='))document.write('<style id="oauth-hide-login">.login-screen{display:none!important}</style>')</script>
  <div class="login-screen" id="loginScreen">
    <div class="logo">
      <svg width="220" height="80" viewBox="0 0 220 80">
        <defs>
          <linearGradient id="logo-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#4F46E5"/>
            <stop offset="100%" stop-color="#7C3AED"/>
          </linearGradient>
        </defs>
        <rect x="0" y="0" width="220" height="80" rx="24" fill="url(#logo-gradient)"/>
        <text x="110" y="54" text-anchor="middle" font-family="Bricolage Grotesque, sans-serif" font-size="42" font-weight="800" fill="white">spraff</text>
      </svg>
    </div>
    <p class="login-tagline">Simple AI chat</p>
    <button class="login-btn" id="loginBtn">Get started</button>
    <a class="login-about" href="https://github.com/martinpllu/spraff" target="_blank">About</a>
  </div>

  <!-- Main Voice Screen -->
  <div class="voice-screen hidden" id="voiceScreen">
    <!-- New Chat Button -->
    <button class="new-chat-btn hidden" id="newChatBtn" title="New chat">
      <svg viewBox="0 0 24 24">
        <path d="M23 4v6h-6"/>
        <path d="M1 20v-6h6"/>
        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
      </svg>
    </button>

    <!-- Conversation History -->
    <div class="conversation-history" id="conversationHistory"></div>

    <!-- Text Input -->
    <div class="text-input-container" id="textInputContainer">
      <div class="text-input-wrapper">
        <textarea class="text-input" id="textInput" placeholder="Type your message..." rows="1"></textarea>
        <button class="text-send-btn" id="textSendBtn">
          <svg viewBox="0 0 24 24">
            <line x1="22" y1="2" x2="11" y2="13"/>
            <polygon points="22 2 15 22 11 13 2 9 22 2"/>
          </svg>
          <div class="spinner-icon"></div>
        </button>
      </div>
    </div>

    <!-- The Button -->
    <div class="button-container">
      <button class="main-button" id="mainButton">
        <svg class="mic-icon" viewBox="0 0 24 24">
          <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
          <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          <line x1="12" y1="19" x2="12" y2="23"/>
          <line x1="8" y1="23" x2="16" y2="23"/>
        </svg>
        <svg class="stop-icon" viewBox="0 0 24 24">
          <rect x="6" y="6" width="12" height="12" rx="1"/>
        </svg>
        <div class="spinner-icon"></div>
      </button>
      <div class="status-text" id="statusText">Ready</div>
      <div class="upload-progress" id="uploadProgress">
        <div class="upload-progress-bar" id="uploadProgressBar"></div>
      </div>
    </div>

    <!-- Hint -->
    <div class="hint-text" id="hintText">
      Press <kbd>space</kbd> or tap the button to speak
    </div>

    <!-- Settings menu - top right -->
    <div class="settings-menu" id="settingsMenu">
      <button class="settings-menu-btn" id="settingsMenuBtn" title="Settings">
        spraff
        <svg viewBox="0 0 24 24" width="16" height="16">
          <circle cx="12" cy="5" r="1.5" fill="currentColor"/>
          <circle cx="12" cy="12" r="1.5" fill="currentColor"/>
          <circle cx="12" cy="19" r="1.5" fill="currentColor"/>
        </svg>
      </button>
      <div class="settings-dropdown" id="settingsDropdown">
        <button id="voiceSettingsBtn">
          <svg viewBox="0 0 24 24">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          </svg>
          Select voice
        </button>
        <button id="costSettingsBtn">
          <svg viewBox="0 0 24 24">
            <line x1="12" y1="1" x2="12" y2="23"/>
            <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
          </svg>
          Cost
        </button>
        <button id="copyChatBtn">
          <svg viewBox="0 0 24 24">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copy chat
        </button>
        <div class="divider"></div>
        <button id="aboutBtn">
          <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="16" x2="12" y2="12"/>
            <line x1="12" y1="8" x2="12.01" y2="8"/>
          </svg>
          About
        </button>
        <button id="privacyBtn">
          <svg viewBox="0 0 24 24">
            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
          </svg>
          Privacy
        </button>
        <button id="logoutBtn">
          <svg viewBox="0 0 24 24">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
            <polyline points="16 17 21 12 16 7"/>
            <line x1="21" y1="12" x2="9" y2="12"/>
          </svg>
          Logout
        </button>
      </div>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls" id="bottomControls">
      <!-- Mode Toggle -->
      <div class="mode-toggle" id="modeToggle">
        <button class="mode-btn active" id="voiceModeBtn" title="Voice mode">
          <svg viewBox="0 0 24 24">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          </svg>
        </button>
        <button class="mode-btn" id="textModeBtn" title="Text mode">
          <svg viewBox="0 0 24 24">
            <path d="M4 7V4h16v3"/>
            <path d="M9 20h6"/>
            <path d="M12 4v16"/>
          </svg>
        </button>
      </div>

      <button class="control-pill search-pill" id="searchToggle">
        <svg viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="8"/>
          <line x1="21" y1="21" x2="16.65" y2="16.65"/>
        </svg>
        <span class="search-label-long">Web Search</span>
        <span class="search-label-short">Search</span>
        <span class="status-indicator" id="searchStatus">off</span>
      </button>
      <button class="control-pill stop-pill hidden" id="stopBtn">
        <svg viewBox="0 0 24 24">
          <rect x="6" y="6" width="12" height="12" rx="1"/>
        </svg>
        <span>Stop</span>
      </button>
    </div>
  </div>


  <div class="error-toast" id="errorToast"></div>

  <script>
    // ============ Configuration ============
    const OPENROUTER_AUTH_URL = 'https://openrouter.ai/auth';
    const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1';
    const MODEL = 'google/gemini-3-flash-preview';
    const MODEL_ONLINE = 'google/gemini-3-flash-preview:online';
    const CALLBACK_URL = window.location.origin + window.location.pathname;

    // ============ Conversation Persistence ============
    function loadConversationHistory() {
      try {
        const saved = localStorage.getItem('conversationHistory');
        return saved ? JSON.parse(saved) : [];
      } catch (e) {
        console.warn('Failed to load conversation history:', e);
        return [];
      }
    }

    function saveConversationHistory() {
      try {
        localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
      } catch (e) {
        console.warn('Failed to save conversation history:', e);
      }
    }

    function clearConversationHistory() {
      conversationHistory = [];
      try {
        localStorage.removeItem('conversationHistory');
      } catch (e) {
        console.warn('Failed to clear conversation history:', e);
      }
    }

    // ============ Pending Voice Message Persistence ============
    function savePendingVoiceMessage(base64Audio) {
      try {
        localStorage.setItem('pendingVoiceMessage', base64Audio);
        localStorage.setItem('pendingVoiceTimestamp', Date.now().toString());
      } catch (e) {
        console.warn('Failed to save pending voice message:', e);
      }
    }

    function clearPendingVoiceMessage() {
      try {
        localStorage.removeItem('pendingVoiceMessage');
        localStorage.removeItem('pendingVoiceTimestamp');
      } catch (e) {
        console.warn('Failed to clear pending voice message:', e);
      }
    }

    function getPendingVoiceMessage() {
      try {
        const audio = localStorage.getItem('pendingVoiceMessage');
        const timestamp = localStorage.getItem('pendingVoiceTimestamp');
        if (audio && timestamp) {
          // Only return if less than 1 hour old
          const age = Date.now() - parseInt(timestamp, 10);
          if (age < 60 * 60 * 1000) {
            return audio;
          } else {
            clearPendingVoiceMessage();
          }
        }
        return null;
      } catch (e) {
        console.warn('Failed to get pending voice message:', e);
        return null;
      }
    }

    // ============ State ============
    let apiKey = localStorage.getItem('openrouter_api_key');
    let isListening = false;
    let conversationHistory = loadConversationHistory();
    let mediaRecorder = null;
    let audioChunks = [];
    let audioStream = null;
    let selectedVoiceName = localStorage.getItem('selectedVoice') || null;
    let webSearchEnabled = false; // Always default to off on page load
    let cloudVoicesEnabled = localStorage.getItem('cloudVoicesEnabled') === 'true';
    let speechQueue = [];
    let isSpeaking = false;
    let shouldStopSpeaking = false;
    let speechTotalChars = 0;
    let speechSpokenChars = 0;
    let speechProgressInterval = null;
    let textMode = localStorage.getItem('textMode') === 'true';
    let isProcessingText = false;
    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    let currentStreamingElement = null;

    // Stats
    const stats = {
      sessionCost: 0,
      lastCost: 0,
      lastVoiceSize: 0
    };

    // ============ DOM Elements ============
    const loginScreen = document.getElementById('loginScreen');
    const voiceScreen = document.getElementById('voiceScreen');
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const mainButton = document.getElementById('mainButton');
    const statusText = document.getElementById('statusText');
    const hintText = document.getElementById('hintText');
    const settingsMenu = document.getElementById('settingsMenu');
    const settingsMenuBtn = document.getElementById('settingsMenuBtn');
    const settingsDropdown = document.getElementById('settingsDropdown');
    const voiceSettingsBtn = document.getElementById('voiceSettingsBtn');
    const searchToggle = document.getElementById('searchToggle');
    const searchStatus = document.getElementById('searchStatus');
    const stopBtn = document.getElementById('stopBtn');
    const voiceModal = document.getElementById('voiceModal');
    const modalClose = document.getElementById('modalClose');
    const voiceList = document.getElementById('voiceList');
    const costModal = document.getElementById('costModal');
    const costModalClose = document.getElementById('costModalClose');
    const costSettingsBtn = document.getElementById('costSettingsBtn');
    const copyChatBtn = document.getElementById('copyChatBtn');
    const costBalance = document.getElementById('costBalance');
    const costLast = document.getElementById('costLast');
    const costSession = document.getElementById('costSession');
    const costVoiceSize = document.getElementById('costVoiceSize');
    const voiceSizeStat = document.getElementById('voiceSizeStat');
    const uploadProgress = document.getElementById('uploadProgress');
    const uploadProgressBar = document.getElementById('uploadProgressBar');
    const aboutModal = document.getElementById('aboutModal');
    const aboutModalClose = document.getElementById('aboutModalClose');
    const aboutBtn = document.getElementById('aboutBtn');
    const privacyModal = document.getElementById('privacyModal');
    const privacyModalClose = document.getElementById('privacyModalClose');
    const privacyBtn = document.getElementById('privacyBtn');
    const errorToast = document.getElementById('errorToast');
    const textInputContainer = document.getElementById('textInputContainer');
    const textInput = document.getElementById('textInput');
    const textSendBtn = document.getElementById('textSendBtn');
    const modeToggle = document.getElementById('modeToggle');
    const voiceModeBtn = document.getElementById('voiceModeBtn');
    const textModeBtn = document.getElementById('textModeBtn');
    const conversationHistoryEl = document.getElementById('conversationHistory');
    const newChatBtn = document.getElementById('newChatBtn');

    // ============ Initialization ============
    function init() {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get('code');

      if (code) {
        handleOAuthCallback(code);
        return;
      }

      if (apiKey) {
        showVoiceScreen();
      } else {
        showLoginScreen();
      }

      updateSearchToggleUI();
      updateModeUI();
      updateNewChatButton();
      setupEventListeners();
      lockOrientation();
      checkPendingVoiceMessage();
    }

    // ============ Pending Voice Message Recovery ============
    async function checkPendingVoiceMessage() {
      if (!apiKey) return;

      const pendingAudio = getPendingVoiceMessage();
      if (pendingAudio) {
        const sizeKB = Math.round(pendingAudio.length * 0.75 / 1024);
        // Auto-retry the upload
        setButtonState('processing');
        statusText.textContent = `Retrying ${sizeKB} KB`;

        try {
          await sendAudioToAPI(pendingAudio);
          clearPendingVoiceMessage();
        } catch (e) {
          console.error('Failed to retry pending voice message:', e);
          showError('Failed to send saved voice message');
          setButtonState('ready');
        }
      }
    }

    // ============ Orientation Lock ============
    function lockOrientation() {
      // Only attempt on mobile devices
      if (!isMobile) return;

      // Try Screen Orientation API (works in some PWA contexts)
      if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('portrait').catch(() => {
          // Silently fail - CSS fallback will handle it
        });
      }
    }

    // ============ OAuth Flow ============
    function generateCodeVerifier() {
      const array = new Uint8Array(32);
      crypto.getRandomValues(array);
      return btoa(String.fromCharCode(...array))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

    async function generateCodeChallenge(verifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(verifier);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return btoa(String.fromCharCode(...new Uint8Array(hash)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

    async function startOAuthFlow() {
      const codeVerifier = generateCodeVerifier();
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      sessionStorage.setItem('code_verifier', codeVerifier);
      const authUrl = `${OPENROUTER_AUTH_URL}?callback_url=${encodeURIComponent(CALLBACK_URL)}&code_challenge=${codeChallenge}&code_challenge_method=S256`;
      window.location.href = authUrl;
    }

    async function handleOAuthCallback(code) {
      const codeVerifier = sessionStorage.getItem('code_verifier');
      if (!codeVerifier) {
        showError('Authentication failed');
        showLoginScreen();
        return;
      }

      try {
        const response = await fetch(`${OPENROUTER_API_URL}/auth/keys`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            code,
            code_verifier: codeVerifier,
            code_challenge_method: 'S256'
          })
        });

        if (!response.ok) throw new Error('Failed to authenticate');

        const data = await response.json();
        apiKey = data.key;
        localStorage.setItem('openrouter_api_key', apiKey);
        sessionStorage.removeItem('code_verifier');
        window.history.replaceState({}, document.title, window.location.pathname);
        showVoiceScreen();
        updateSearchToggleUI();
        updateModeUI();
        setupEventListeners();
      } catch (error) {
        console.error('OAuth error:', error);
        showError('Authentication failed');
        showLoginScreen();
      }
    }

    function logout() {
      apiKey = null;
      localStorage.removeItem('openrouter_api_key');
      clearConversationHistory();
      showLoginScreen();
    }

    // ============ UI State ============
    function showLoginScreen() {
      // Remove the style tag injected during OAuth callback (if present)
      document.getElementById('oauth-hide-login')?.remove();
      loginScreen.classList.remove('hidden');
      voiceScreen.classList.add('hidden');
    }

    function showVoiceScreen() {
      loginScreen.classList.add('hidden');
      voiceScreen.classList.remove('hidden');
    }

    function setButtonState(state) {
      mainButton.classList.remove('listening', 'processing', 'speaking');
      statusText.classList.remove('listening', 'speaking');

      switch (state) {
        case 'listening':
          mainButton.classList.add('listening');
          statusText.classList.add('listening');
          statusText.textContent = 'Listening';
          hintText.classList.add('hidden');
          break;
        case 'processing':
          mainButton.classList.add('processing');
          statusText.textContent = 'Thinking';
          hintText.classList.add('hidden');
          break;
        case 'speaking':
          mainButton.classList.add('speaking');
          statusText.classList.add('speaking');
          statusText.textContent = 'Speaking';
          hintText.classList.add('hidden');
          break;
        default:
          statusText.textContent = 'Ready';
          hintText.classList.remove('hidden');
      }
    }

    function showError(message) {
      errorToast.textContent = message;
      errorToast.classList.add('visible');
      setTimeout(() => errorToast.classList.remove('visible'), 4000);
    }

    function updateSearchToggleUI() {
      searchToggle.classList.toggle('active', webSearchEnabled);
      searchStatus.textContent = webSearchEnabled ? 'on' : 'off';
    }

    function updateSessionCost(cost) {
      stats.lastCost = cost;
      stats.sessionCost += cost;
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    function showUploadProgress(visible) {
      if (visible) {
        uploadProgress.classList.add('visible');
        uploadProgress.classList.remove('speaking');
        uploadProgressBar.style.width = '0%';
      } else {
        uploadProgress.classList.remove('visible');
        uploadProgress.classList.remove('speaking');
      }
    }

    function setUploadProgress(percent) {
      uploadProgressBar.style.width = Math.min(100, percent) + '%';
    }

    function showSpeechProgress(visible) {
      if (visible) {
        uploadProgress.classList.add('visible', 'speaking');
        uploadProgressBar.style.width = '0%';
      } else {
        uploadProgress.classList.remove('visible', 'speaking');
        if (speechProgressInterval) {
          clearInterval(speechProgressInterval);
          speechProgressInterval = null;
        }
      }
    }

    function setSpeechProgress(percent) {
      uploadProgressBar.style.width = Math.min(100, percent) + '%';
    }

    async function openCostModal() {
      settingsDropdown.classList.remove('open');
      costModal.classList.remove('hidden');

      // Update session stats
      costLast.textContent = stats.lastCost > 0 ? `$${stats.lastCost.toFixed(5)}` : '—';
      costSession.textContent = `$${stats.sessionCost.toFixed(5)}`;

      // Show voice size if we have one
      if (stats.lastVoiceSize > 0) {
        voiceSizeStat.style.display = '';
        costVoiceSize.textContent = formatFileSize(stats.lastVoiceSize);
      } else {
        voiceSizeStat.style.display = 'none';
      }

      // Fetch balance
      costBalance.textContent = '...';
      try {
        const response = await fetch(`${OPENROUTER_API_URL}/credits`, {
          headers: { 'Authorization': `Bearer ${apiKey}` }
        });
        if (response.ok) {
          const data = await response.json();
          const totalCredits = data.data?.total_credits ?? 0;
          const totalUsage = data.data?.total_usage ?? 0;
          const balance = totalCredits - totalUsage;
          costBalance.textContent = `$${balance.toFixed(2)}`;
        } else {
          costBalance.textContent = '—';
        }
      } catch (e) {
        console.warn('Failed to fetch balance:', e);
        costBalance.textContent = '—';
      }
    }

    function closeCostModal() {
      costModal.classList.add('hidden');
    }

    async function copyChat() {
      settingsDropdown.classList.remove('open');

      if (conversationHistory.length === 0) {
        showError('No conversation to copy');
        return;
      }

      let markdown = '';
      for (const msg of conversationHistory) {
        if (msg.role === 'user') {
          markdown += `**You:** ${msg.content}\n\n`;
        } else {
          markdown += `**Assistant:** ${msg.content}\n\n`;
        }
      }

      try {
        await navigator.clipboard.writeText(markdown.trim());
        // Show brief success feedback
        const originalText = copyChatBtn.textContent;
        copyChatBtn.innerHTML = `<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg> Copied!`;
        setTimeout(() => {
          copyChatBtn.innerHTML = `<svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy chat`;
        }, 1500);
      } catch (e) {
        showError('Failed to copy to clipboard');
      }
    }

    // ============ Markdown Parsing ============
    function parseMarkdown(text) {
      if (!text) return '';

      let html = text;

      // Helper to escape HTML
      const escapeHtml = (str) => str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Code blocks - extract first and replace with placeholders
      const codeBlocks = [];
      html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (_, lang, code) => {
        const trimmed = code.replace(/^\n+|\n+$/g, '');
        const placeholder = `\x00CODEBLOCK${codeBlocks.length}\x00`;
        codeBlocks.push(`<pre><code>${escapeHtml(trimmed)}</code></pre>`);
        return placeholder;
      });

      // Tables (before HTML escaping, so we can detect pipe characters)
      // Process line by line to find table blocks
      const tableInputLines = html.split('\n');
      const processedLines = [];
      let tableLines = [];

      for (let i = 0; i < tableInputLines.length; i++) {
        const line = tableInputLines[i].trim();
        const isTableRow = line.startsWith('|') && line.endsWith('|');

        if (isTableRow) {
          tableLines.push(line);
        } else {
          // Process accumulated table lines if any
          if (tableLines.length >= 2) {
            const table = parseTable(tableLines, escapeHtml);
            if (table) {
              processedLines.push(table);
            } else {
              processedLines.push(...tableLines);
            }
          } else if (tableLines.length > 0) {
            processedLines.push(...tableLines);
          }
          tableLines = [];
          processedLines.push(tableInputLines[i]);
        }
      }

      // Handle table at end of content
      if (tableLines.length >= 2) {
        const table = parseTable(tableLines, escapeHtml);
        if (table) {
          processedLines.push(table);
        } else {
          processedLines.push(...tableLines);
        }
      } else if (tableLines.length > 0) {
        processedLines.push(...tableLines);
      }

      html = processedLines.join('\n');

      function parseTable(rows, escape) {
        if (rows.length < 2) return null;

        // Check if second row is separator (|---|---|)
        const separatorRow = rows[1];
        if (!/^\|[\s\-:]+(\|[\s\-:]+)+\|$/.test(separatorRow)) return null;

        let tableHtml = '<div class="table-wrapper"><table>';

        // Header row
        const headerCells = rows[0].split('|').slice(1, -1);
        tableHtml += '<thead><tr>';
        headerCells.forEach(cell => {
          tableHtml += '<th>' + escape(cell.trim()) + '</th>';
        });
        tableHtml += '</tr></thead>';

        // Body rows (skip header and separator)
        if (rows.length > 2) {
          tableHtml += '<tbody>';
          for (let i = 2; i < rows.length; i++) {
            const cells = rows[i].split('|').slice(1, -1);
            tableHtml += '<tr>';
            cells.forEach(cell => {
              tableHtml += '<td>' + escape(cell.trim()) + '</td>';
            });
            tableHtml += '</tr>';
          }
          tableHtml += '</tbody>';
        }

        tableHtml += '</table></div>';
        return tableHtml;
      }

      // Escape HTML for remaining content (but not the table HTML we just created)
      html = html.replace(/^(?!<div|<\/div|<table|<\/table|<thead|<\/thead|<tbody|<\/tbody|<tr|<\/tr|<th|<\/th|<td|<\/td)(.*)$/gm, (match) => {
        if (match.startsWith('<div') || match.startsWith('</div') ||
            match.startsWith('<table') || match.startsWith('</table') ||
            match.startsWith('<thead') || match.startsWith('</thead') ||
            match.startsWith('<tbody') || match.startsWith('</tbody') ||
            match.startsWith('<tr') || match.startsWith('</tr') ||
            match.startsWith('<th') || match.startsWith('</th') ||
            match.startsWith('<td') || match.startsWith('</td')) {
          return match;
        }
        return match
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      });

      // Inline code (must be before other inline processing)
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Headers
      html = html.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
      html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
      html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
      html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');

      // Bold and italic (order matters)
      html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
      html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
      html = html.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
      html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
      html = html.replace(/_(.+?)_/g, '<em>$1</em>');

      // Links
      html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

      // Blockquotes
      html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');

      // Horizontal rules
      html = html.replace(/^---$/gm, '<hr>');
      html = html.replace(/^\*\*\*$/gm, '<hr>');

      // Unordered lists
      html = html.replace(/^[\-\*] (.+)$/gm, '<li>$1</li>');
      html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

      // Ordered lists
      html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
      // Only wrap consecutive <li> that aren't already in <ul>
      html = html.replace(/(<li>.*<\/li>\n?)(?!<\/ul>)/g, (match, p1, offset) => {
        const before = html.substring(0, offset);
        if (before.endsWith('<ul>') || before.match(/<li>.*<\/li>\n?$/)) {
          return match;
        }
        return match;
      });

      // Paragraphs - wrap lines that aren't already wrapped
      const lines = html.split('\n');
      const processed = [];
      let inList = false;

      for (let line of lines) {
        const trimmed = line.trim();
        if (!trimmed) {
          processed.push('');
          continue;
        }

        // Check if line is already an HTML element
        if (trimmed.match(/^<(h[1-4]|ul|ol|li|pre|blockquote|hr|p|table|thead|tbody|tr|th|td)/)) {
          processed.push(line);
          continue;
        }

        // Track list state
        if (trimmed.startsWith('<ul>') || trimmed.startsWith('<ol>')) {
          inList = true;
        }
        if (trimmed.endsWith('</ul>') || trimmed.endsWith('</ol>')) {
          inList = false;
        }

        if (inList || trimmed.startsWith('<li>')) {
          processed.push(line);
        } else {
          processed.push(`<p>${trimmed}</p>`);
        }
      }

      html = processed.join('\n');

      // Clean up empty paragraphs and normalize
      html = html.replace(/<p><\/p>/g, '');
      html = html.replace(/\n+/g, '\n');

      // Restore code blocks from placeholders
      codeBlocks.forEach((block, i) => {
        html = html.replace(`\x00CODEBLOCK${i}\x00`, block);
        html = html.replace(`<p>\x00CODEBLOCK${i}\x00</p>`, block);
      });

      return html;
    }

    // ============ New Chat ============
    function startNewChat() {
      clearConversationHistory();
      clearPendingVoiceMessage();
      conversationHistoryEl.innerHTML = '';
      stats.sessionCost = 0;
      stats.lastCost = 0;
      stats.lastVoiceSize = 0;
      updateNewChatButton();
    }

    function updateNewChatButton() {
      if (conversationHistory.length > 0) {
        newChatBtn.classList.remove('hidden');
      } else {
        newChatBtn.classList.add('hidden');
      }
    }

    // ============ Mode Switching ============
    function updateModeUI() {
      if (textMode) {
        voiceScreen.classList.add('text-mode');
        textInputContainer.classList.add('visible');
        conversationHistoryEl.classList.add('visible');
        voiceModeBtn.classList.remove('active');
        textModeBtn.classList.add('active');
        renderConversationHistory();
        // Only auto-focus on desktop to avoid keyboard popping up on mobile
        if (!isMobile) {
          textInput.focus();
        }
      } else {
        voiceScreen.classList.remove('text-mode');
        textInputContainer.classList.remove('visible');
        conversationHistoryEl.classList.remove('visible');
        voiceModeBtn.classList.add('active');
        textModeBtn.classList.remove('active');
      }
    }

    function setTextMode(enabled) {
      textMode = enabled;
      localStorage.setItem('textMode', enabled);
      updateModeUI();
    }

    function renderConversationHistory() {
      conversationHistoryEl.innerHTML = '';

      for (let i = 0; i < conversationHistory.length; i += 2) {
        const userMsg = conversationHistory[i];
        const assistantMsg = conversationHistory[i + 1];

        if (userMsg) {
          const group = document.createElement('div');
          group.className = 'message-group';

          const userEl = document.createElement('div');
          userEl.className = 'message user';
          userEl.textContent = userMsg.content;
          group.appendChild(userEl);

          if (assistantMsg) {
            const assistantEl = document.createElement('div');
            assistantEl.className = 'message assistant';
            assistantEl.innerHTML = parseMarkdown(assistantMsg.content);
            group.appendChild(assistantEl);
          }

          conversationHistoryEl.appendChild(group);
        }
      }

      scrollToBottom();
    }

    function scrollToBottom() {
      conversationHistoryEl.scrollTop = conversationHistoryEl.scrollHeight;
    }

    function addMessageToHistory(role, content, streaming = false) {
      // Find the last message group (skip spacer if present)
      let group = conversationHistoryEl.lastElementChild;
      if (group && group.classList.contains('scroll-spacer')) {
        group = group.previousElementSibling;
      }

      if (role === 'user') {
        // Ensure spacer exists at the end
        let spacer = conversationHistoryEl.querySelector('.scroll-spacer');
        if (!spacer) {
          spacer = document.createElement('div');
          spacer.className = 'scroll-spacer';
          conversationHistoryEl.appendChild(spacer);
        }
        // Spacer height = viewport height so we can scroll the last item to top
        spacer.style.height = conversationHistoryEl.clientHeight + 'px';

        // Create new group for user message, insert before spacer
        group = document.createElement('div');
        group.className = 'message-group';
        conversationHistoryEl.insertBefore(group, spacer);

        const userEl = document.createElement('div');
        userEl.className = 'message user';
        userEl.textContent = content;
        group.appendChild(userEl);

        // Scroll so user message appears at top of visible area
        requestAnimationFrame(() => {
          // Calculate how far the group is from the top of the scrollable content
          // by measuring its position relative to the container and adding current scroll
          const containerTop = conversationHistoryEl.getBoundingClientRect().top;
          const groupTop = group.getBoundingClientRect().top;
          const relativePosition = groupTop - containerTop;
          const scrollTarget = conversationHistoryEl.scrollTop + relativePosition - 72; // 72px = ~4.5rem padding
          conversationHistoryEl.scrollTo({
            top: Math.max(0, scrollTarget),
            behavior: 'smooth'
          });
        });
        return;
      } else {
        // Assistant message goes in the last group
        if (!group) {
          group = document.createElement('div');
          group.className = 'message-group';
          conversationHistoryEl.appendChild(group);
        }

        let assistantEl = group.querySelector('.message.assistant');
        if (!assistantEl) {
          assistantEl = document.createElement('div');
          assistantEl.className = 'message assistant';
          group.appendChild(assistantEl);
        }

        assistantEl.textContent = content;
        if (streaming) {
          assistantEl.classList.add('streaming');
          currentStreamingElement = assistantEl;
        } else {
          assistantEl.classList.remove('streaming');
          currentStreamingElement = null;
        }
      }
    }

    function updateStreamingMessage(content) {
      if (currentStreamingElement) {
        currentStreamingElement.innerHTML = parseMarkdown(content);
      }
    }

    function finishStreamingMessage() {
      if (currentStreamingElement) {
        currentStreamingElement.classList.remove('streaming');
        currentStreamingElement = null;
      }
    }

    // ============ Audio Recording ============
    async function startRecording() {
      try {
        audioChunks = [];

        // Check if mediaDevices API is available
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          console.error('mediaDevices API not available');
          showError('Browser does not support audio recording');
          return;
        }

        // Enumerate devices first to check what's available
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const audioInputs = devices.filter(d => d.kind === 'audioinput');
          console.log('Available audio inputs:', audioInputs);

          if (audioInputs.length === 0) {
            showError('No microphone found. Check browser permissions.');
            setButtonState('ready');
            return;
          }
        } catch (enumError) {
          console.warn('Could not enumerate devices:', enumError);
        }

        // Try with explicit constraints - helps with some Brave configurations
        const constraints = {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        };
        audioStream = await navigator.mediaDevices.getUserMedia(constraints);

        // iOS Safari: unlock audio context and speech synthesis on user gesture
        if (!window.audioUnlocked) {
          // Unlock Web Audio API
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const buffer = audioCtx.createBuffer(1, 1, 22050);
          const source = audioCtx.createBufferSource();
          source.buffer = buffer;
          source.connect(audioCtx.destination);
          source.start(0);

          // Also unlock speechSynthesis with a space character (empty string doesn't work on iOS)
          if (window.speechSynthesis) {
            const unlockUtterance = new SpeechSynthesisUtterance(' ');
            unlockUtterance.volume = 0.01;
            speechSynthesis.speak(unlockUtterance);
          }
          window.audioUnlocked = true;
        }

        let mimeType = 'audio/webm';
        if (MediaRecorder.isTypeSupported('audio/mp4')) {
          mimeType = 'audio/mp4';
        } else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mimeType = 'audio/webm;codecs=opus';
        }

        mediaRecorder = new MediaRecorder(audioStream, { mimeType });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: mimeType });
          audioStream.getTracks().forEach(track => track.stop());
          audioStream = null;

          try {
            const wavBlob = await convertToWav(audioBlob);
            const base64Audio = await blobToBase64(wavBlob);
            // Save before upload in case of page refresh
            savePendingVoiceMessage(base64Audio);
            await sendAudioToAPI(base64Audio);
            // Clear on success
            clearPendingVoiceMessage();
          } catch (e) {
            console.error('Audio conversion error:', e);
            showError('Failed to process audio');
            setButtonState('ready');
          }
        };

        mediaRecorder.start();
        isListening = true;
        setButtonState('listening');
        searchToggle.classList.add('hidden');

      } catch (error) {
        console.error('Microphone error:', error);
        showError('Microphone access denied');
        setButtonState('ready');
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      isListening = false;
      setButtonState('processing');
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    async function convertToWav(audioBlob) {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const arrayBuffer = await audioBlob.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      // Downsample to 16kHz for speech (Gemini downsamples anyway, saves bandwidth)
      const targetSampleRate = 16000;
      const resampledBuffer = await resampleAudio(audioContext, audioBuffer, targetSampleRate);

      const wavBuffer = audioBufferToWav(resampledBuffer, targetSampleRate);
      return new Blob([wavBuffer], { type: 'audio/wav' });
    }

    async function resampleAudio(audioContext, audioBuffer, targetSampleRate) {
      // If already at or below target rate, just return mono version
      if (audioBuffer.sampleRate <= targetSampleRate) {
        return audioBuffer;
      }

      // Create offline context at target sample rate
      const numSamples = Math.round(audioBuffer.duration * targetSampleRate);
      const offlineContext = new OfflineAudioContext(1, numSamples, targetSampleRate);

      // Create buffer source
      const source = offlineContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(offlineContext.destination);
      source.start(0);

      // Render resampled audio
      return await offlineContext.startRendering();
    }

    function audioBufferToWav(buffer, targetSampleRate) {
      const sampleRate = targetSampleRate || buffer.sampleRate;
      const format = 1;
      const bitDepth = 16;
      const numChannels = 1; // Always mono for speech

      // Get mono audio data (mix down if stereo)
      let samples;
      if (buffer.numberOfChannels === 2) {
        const left = buffer.getChannelData(0);
        const right = buffer.getChannelData(1);
        samples = new Float32Array(left.length);
        for (let i = 0; i < left.length; i++) {
          samples[i] = (left[i] + right[i]) / 2;
        }
      } else {
        samples = buffer.getChannelData(0);
      }

      const dataLength = samples.length * (bitDepth / 8);
      const wavBuffer = new ArrayBuffer(44 + dataLength);
      const view = new DataView(wavBuffer);

      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataLength, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
      view.setUint16(32, numChannels * (bitDepth / 8), true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);

      for (let i = 0; i < samples.length; i++) {
        const sample = Math.max(-1, Math.min(1, samples[i]));
        view.setInt16(44 + i * 2, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      }

      return wavBuffer;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // ============ API Communication ============
    function getModel() {
      return webSearchEnabled ? MODEL_ONLINE : MODEL;
    }

    function buildSystemPrompt() {
      const today = new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      const searchButtonName = window.innerWidth <= 480 ? 'Search' : 'Web Search';
      const webSearchNote = webSearchEnabled
        ? 'Web search is ENABLED for this query. You have access to current information from the web.'
        : `Web search is currently DISABLED for this query. If the user asks about recent events, current news, weather, sports scores, stock prices, or anything that requires up-to-date information, DO NOT attempt to answer from your training data. Instead, give a brief response like: "I'll need web search enabled for current news. Tap the ${searchButtonName} button and ask me again." Keep it short and direct.`;

      return `You are a helpful assistant that can communicate via voice or text. Today is ${today}.

The user is currently in VOICE MODE - they spoke this message aloud and your response will be read aloud via text-to-speech. Previous messages in the conversation may have been via text or voice.

${webSearchNote}

NOTE: The technical details in this system prompt (about voice mode, text-to-speech, etc.) are about HOW to format your response, not WHAT to talk about. Answer the user's actual question - don't let these instructions bias your content toward tech topics.

CRITICAL REQUIREMENTS:

1. TRANSCRIPTION: You MUST start your response by transcribing exactly what the user said in their audio message using [USER]...[/USER] tags. Listen carefully to their audio and write what they said:

[USER]
<transcribe the user's spoken words here>
[/USER]

<your response here>

2. SPEECH-FRIENDLY OUTPUT: Your response will be converted to speech, so you MUST:
- Be concise and conversational
- NEVER include URLs or links - they sound terrible spoken aloud. Describe sources naturally, e.g. "according to Simon Willison's blog" not "according to simonwillison.net"
- NEVER use domain names like ".com", ".io", ".net", etc.
- Avoid all technical formatting, code, or special characters
- No lists or bullet points - use flowing sentences instead

Respond naturally as if having a spoken conversation.`;
    }

    async function sendAudioToAPI(base64Audio) {
      const requestStartTime = performance.now();
      shouldStopSpeaking = false;
      speechQueue = [];

      // Calculate and store voice message size (base64 to bytes: ~75% of base64 length)
      const audioSizeBytes = Math.round(base64Audio.length * 0.75);
      stats.lastVoiceSize = audioSizeBytes;

      // Build request body
      const requestBody = JSON.stringify({
        model: getModel(),
        stream: true,
        messages: [
          { role: 'system', content: buildSystemPrompt() },
          ...conversationHistory,
          {
            role: 'user',
            content: [
              { type: 'input_audio', input_audio: { data: base64Audio, format: 'wav' } }
            ]
          }
        ],
        provider: {
          only: ['google-vertex'],
          allow_fallbacks: false,
          zdr: true
        }
      });

      const payloadSize = new Blob([requestBody]).size;

      // Show uploading status for large payloads (>100KB)
      const isLargeUpload = payloadSize > 100 * 1024;
      const payloadSizeKB = Math.round(payloadSize / 1024);
      if (isLargeUpload) {
        statusText.textContent = `Uploading ${payloadSizeKB} KB`;
        showUploadProgress(true);
      }

      try {
        // Use XHR for upload progress tracking, then process streaming response
        const response = await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', `${OPENROUTER_API_URL}/chat/completions`);
          xhr.setRequestHeader('Authorization', `Bearer ${apiKey}`);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.setRequestHeader('HTTP-Referer', window.location.origin);
          xhr.setRequestHeader('X-Title', 'Spraff');

          // Track real upload progress
          if (isLargeUpload) {
            xhr.upload.onprogress = (e) => {
              if (e.lengthComputable) {
                const percent = (e.loaded / e.total) * 100;
                setUploadProgress(percent);
              }
            };

            xhr.upload.onload = () => {
              setUploadProgress(100);
              statusText.textContent = 'Thinking';
              setTimeout(() => showUploadProgress(false), 300);
            };
          }

          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve(xhr.responseText);
            } else {
              try {
                const error = JSON.parse(xhr.responseText);
                reject(new Error(error.error?.message || 'API request failed'));
              } catch {
                reject(new Error('API request failed'));
              }
            }
          };

          xhr.onerror = () => reject(new Error('Network error'));
          xhr.send(requestBody);
        });

        showUploadProgress(false);

        // Parse the SSE response (XHR doesn't stream, so we process all at once)
        const lines = response.split('\n');
        let fullResponse = '';
        let usage = null;
        let userTranscript = null;
        let transcriptExtracted = false;

        for (const line of lines) {
          const trimmedLine = line.trim();
          if (!trimmedLine || !trimmedLine.startsWith('data: ')) continue;

          const data = trimmedLine.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            if (parsed.usage) usage = parsed.usage;

            const content = parsed.choices?.[0]?.delta?.content;
            if (content) {
              fullResponse += content;

              // Extract user transcript
              if (!transcriptExtracted) {
                const match = fullResponse.match(/\[USER\]\s*([\s\S]*?)\s*\[\/USER\]/);
                if (match) {
                  userTranscript = match[1].trim();
                  transcriptExtracted = true;
                }
              }
            }
          } catch (e) {}
        }

        // Now speak the response
        setButtonState('speaking');
        searchToggle.classList.add('hidden');
        stopBtn.classList.remove('hidden');

        // Get the response text (after transcript)
        let responseOnly = fullResponse;
        const endTagIndex = fullResponse.indexOf('[/USER]');
        if (endTagIndex !== -1) {
          responseOnly = fullResponse.slice(endTagIndex + 7).trim();
        }

        // Queue speech for the entire response, sentence by sentence
        const sentences = responseOnly.match(/[^.!?]+[.!?]+/g) || [responseOnly];
        for (let i = 0; i < sentences.length; i++) {
          queueSpeech(sentences[i].trim(), i === 0);
        }

        // Update stats from API response
        if (usage && typeof usage.cost === 'number') {
          updateSessionCost(usage.cost);
        }

        // Save to conversation history (keep speech hints for display)
        conversationHistory.push({ role: 'user', content: userTranscript || '[voice message]' });
        conversationHistory.push({ role: 'assistant', content: responseOnly });
        saveConversationHistory();
        updateNewChatButton();

      } catch (error) {
        showUploadProgress(false);
        console.error('API error:', error);
        showError(error.message);
        setButtonState('ready');
        searchToggle.classList.remove('hidden');
        stopBtn.classList.add('hidden');
      }
    }

    function buildTextSystemPrompt() {
      const today = new Date().toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      const searchButtonName = window.innerWidth <= 480 ? 'Search' : 'Web Search';
      const webSearchNote = webSearchEnabled
        ? 'Web search is ENABLED for this query. You have access to current information from the web.'
        : `Web search is currently DISABLED for this query. If the user asks about recent events, current news, weather, sports scores, stock prices, or anything that requires up-to-date information, DO NOT attempt to answer from your training data. Instead, briefly tell them to enable the "${searchButtonName}" toggle and ask again.`;

      return `You are a helpful assistant that can communicate via voice or text. Today is ${today}.

The user is currently in TEXT MODE - they typed this message and will read your response on screen. Previous messages in the conversation may have been via text or voice.

${webSearchNote}

Because this response will be read on screen, you can use:
- Markdown formatting (bold, lists, code blocks) when helpful
- URLs and links if relevant
- Technical details and code snippets if appropriate

Be concise and direct in your responses. Focus on being helpful and informative.`;
    }

    async function sendTextToAPI(userText) {
      if (!userText.trim() || isProcessingText) return;

      // Test feature: NNNw generates NNN words on a random topic
      const wordMatch = userText.trim().match(/^(\d+)w$/);
      if (wordMatch) {
        const wordCount = parseInt(wordMatch[1], 10);
        userText = `Write exactly ${wordCount} words on a random interesting topic. Pick something unexpected and engaging.`;
      }

      isProcessingText = true;
      textSendBtn.classList.add('loading');
      textInput.disabled = true;
      stopBtn.classList.remove('hidden');
      searchToggle.classList.add('hidden');

      // Add user message to UI
      addMessageToHistory('user', userText);

      // Start streaming response
      addMessageToHistory('assistant', '', true);

      try {
        const response = await fetch(`${OPENROUTER_API_URL}/chat/completions`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': window.location.origin,
            'X-Title': 'Spraff'
          },
          body: JSON.stringify({
            model: getModel(),
            stream: true,
            messages: [
              { role: 'system', content: buildTextSystemPrompt() },
              ...conversationHistory,
              { role: 'user', content: userText }
            ],
            provider: {
              only: ['google-vertex'],
              allow_fallbacks: false,
              zdr: true
            }
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || 'API request failed');
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';
        let buffer = '';
        let usage = null;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine || !trimmedLine.startsWith('data: ')) continue;

            const data = trimmedLine.slice(6);
            if (data === '[DONE]') continue;

            try {
              const parsed = JSON.parse(data);
              if (parsed.usage) usage = parsed.usage;

              const content = parsed.choices?.[0]?.delta?.content;
              if (content) {
                fullResponse += content;
                updateStreamingMessage(fullResponse);
              }
            } catch (e) {}
          }
        }

        finishStreamingMessage();

        // Update stats
        if (usage && typeof usage.cost === 'number') {
          updateSessionCost(usage.cost);
        }

        // Save to conversation history
        conversationHistory.push({ role: 'user', content: userText });
        conversationHistory.push({ role: 'assistant', content: fullResponse });
        saveConversationHistory();
        updateNewChatButton();

      } catch (error) {
        console.error('API error:', error);
        showError(error.message);
        finishStreamingMessage();
        // Remove the empty assistant message if we failed
        const lastGroup = conversationHistoryEl.lastElementChild;
        if (lastGroup) {
          const assistantEl = lastGroup.querySelector('.message.assistant');
          if (assistantEl && !assistantEl.textContent) {
            assistantEl.remove();
          }
        }
      } finally {
        isProcessingText = false;
        textSendBtn.classList.remove('loading');
        textInput.disabled = false;
        // Only auto-focus on desktop to avoid keyboard popping up on mobile
        if (!isMobile) {
          textInput.focus();
        }
        stopBtn.classList.add('hidden');
        searchToggle.classList.remove('hidden');
        // Reset web search after each response
        if (webSearchEnabled) {
          webSearchEnabled = false;
          localStorage.setItem('webSearchEnabled', 'false');
          updateSearchToggleUI();
        }
      }
    }

    // ============ Text Processing ============
    function sanitizeForSpeech(text) {
      return text
        .replace(/^#{1,6}\s+/gm, '')
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
        .replace(/https?:\/\/[^\s)]+/g, '')
        .replace(/\*\*([^*]+)\*\*/g, '$1')
        .replace(/\*([^*]+)\*/g, '$1')
        .replace(/__([^_]+)__/g, '$1')
        .replace(/_([^_]+)_/g, '$1')
        .replace(/```[\s\S]*?```/g, '')
        .replace(/`([^`]+)`/g, '$1')
        .replace(/^>\s*/gm, '')
        .replace(/^[-*+]\s+/gm, ', ')
        .replace(/^\d+\.\s+/gm, ', ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    // ============ Text-to-Speech ============
    function queueSpeech(text, isFirst = false) {
      if (!text.trim() || shouldStopSpeaking) return;
      const sanitized = sanitizeForSpeech(text);
      if (!sanitized) return;

      // Track total characters for progress
      if (isFirst) {
        speechTotalChars = 0;
        speechSpokenChars = 0;
      }
      speechTotalChars += sanitized.length;

      speechQueue.push(sanitized);
      if (!isSpeaking) processQueue();
    }

    function processQueue() {
      if (shouldStopSpeaking || speechQueue.length === 0) {
        isSpeaking = false;
        if (speechQueue.length === 0) {
          showSpeechProgress(false);
          setButtonState('ready');
          searchToggle.classList.remove('hidden');
          stopBtn.classList.add('hidden');
        }
        return;
      }

      isSpeaking = true;
      const text = speechQueue.shift();
      const textLength = text.length;

      // Show speech progress bar
      if (speechTotalChars > 0) {
        showSpeechProgress(true);
        setSpeechProgress((speechSpokenChars / speechTotalChars) * 100);
      }

      if (!window.speechSynthesis) {
        speechSpokenChars += textLength;
        processQueue();
        return;
      }

      // iOS Safari workaround: cancel any pending speech first
      speechSynthesis.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1;
      utterance.pitch = 1;
      utterance.volume = 1;

      // Select voice
      const voices = speechSynthesis.getVoices();
      let voice = null;

      if (selectedVoiceName) {
        voice = voices.find(v => v.name === selectedVoiceName);
      }

      // Fallback to default voice if selected not found
      if (!voice) {
        voice = getDefaultVoice(voices);
      }

      if (voice) {
        utterance.voice = voice;
      }

      // iOS Safari fix: onend often doesn't fire, use timeout as fallback
      let ended = false;
      const markEnded = () => {
        if (ended) return;
        ended = true;
        if (speechProgressInterval) {
          clearInterval(speechProgressInterval);
          speechProgressInterval = null;
        }
        speechSpokenChars += textLength;
        processQueue();
      };

      utterance.onend = markEnded;
      utterance.onerror = markEnded;

      // Animate progress during speech using estimated timing
      const estimatedDuration = Math.max(2000, text.length * 80);
      const startChars = speechSpokenChars;
      const speechStartTime = performance.now();
      speechProgressInterval = setInterval(() => {
        if (speechTotalChars > 0) {
          const elapsed = performance.now() - speechStartTime;
          const charsSpoken = Math.min(textLength, (elapsed / estimatedDuration) * textLength);
          const totalProgress = ((startChars + charsSpoken) / speechTotalChars) * 100;
          setSpeechProgress(totalProgress);
        }
      }, 50);

      // Fallback timeout for iOS
      setTimeout(() => {
        if (!ended && isSpeaking) {
          console.warn('Speech timeout fallback triggered');
          markEnded();
        }
      }, estimatedDuration);

      // iOS Safari: need to resume in case it's paused
      speechSynthesis.resume();
      speechSynthesis.speak(utterance);
    }

    function stopSpeaking() {
      shouldStopSpeaking = true;
      speechQueue = [];
      speechSynthesis.cancel();
      isSpeaking = false;
      showSpeechProgress(false);
      setButtonState('ready');
      searchToggle.classList.remove('hidden');
      stopBtn.classList.add('hidden');
    }

    // ============ Voice Settings ============
    function isCloudVoice(voice) {
      return voice.localService === false;
    }

    // Recommended voices - high quality on-device voices
    const recommendedVoices = [
      'Samantha (Enhanced)', 'Ava (Premium)', 'Zoe (Premium)', 'Tom (Enhanced)',
      'Serena (Premium)', 'Daniel (Enhanced)', 'Karen (Enhanced)',
      'Google UK English Female', 'Google UK English Male', 'Google US English',
      // Windows natural voices
      'Microsoft Jenny', 'Microsoft Aria', 'Microsoft Guy'
    ];

    // Low quality, novelty, or problematic voices to filter out
    const voiceBlacklist = [
      // Apple Novelty/Effects voices
      'Albert', 'Bad News', 'Bahh', 'Bells', 'Boing', 'Bubbles', 'Cellos',
      'Deranged', 'Fred', 'Good News', 'Hysterical', 'Jester', 'Junior',
      'Kathy', 'Organ', 'Superstar', 'Trinoids', 'Whisper', 'Wobble',
      'Zarvox', 'Ralph', 'Agnes', 'Bruce', 'Vicki', 'Victoria', 'Princess',
      // Apple Eloquence voices (robotic)
      'Eddy', 'Flo', 'Grandma', 'Grandpa', 'Reed', 'Rocko', 'Sandy', 'Shelley',
      // eSpeak voices
      'eSpeak', 'espeak'
    ];

    function isBlacklisted(voice) {
      const name = voice.name;
      return voiceBlacklist.some(blocked => name.includes(blocked));
    }

    function isRecommended(voice) {
      return recommendedVoices.some(name => voice.name.includes(name));
    }

    // Get the default voice using the same logic as processQueue
    function getDefaultVoice(voices) {
      const preferredLocal = [
        'Samantha (Enhanced)', 'Ava (Premium)', 'Zoe (Premium)', 'Tom (Enhanced)',
        'Serena (Premium)', 'Daniel (Enhanced)', 'Karen (Enhanced)', 'Alex',
        'Samantha', 'Daniel', 'Karen', 'Moira', 'Tessa'
      ];

      for (const name of preferredLocal) {
        const voice = voices.find(v => v.name.includes(name) && v.localService !== false);
        if (voice) return voice;
      }

      // Fallback to any English local voice
      let voice = voices.find(v => v.lang.startsWith('en') && v.localService !== false);
      if (voice) return voice;

      // Last resort: any English voice
      return voices.find(v => v.lang.startsWith('en'));
    }

    // Initialize default voice at startup
    function initDefaultVoice() {
      if (selectedVoiceName) return; // Already have a selection

      const voices = speechSynthesis.getVoices();
      const englishVoices = voices.filter(v => v.lang.startsWith('en'));
      if (englishVoices.length === 0) return;

      const defaultVoice = getDefaultVoice(englishVoices);
      if (defaultVoice) {
        selectedVoiceName = defaultVoice.name;
        localStorage.setItem('selectedVoice', defaultVoice.name);
      }
    }

    function populateVoiceList() {
      const voices = speechSynthesis.getVoices();

      // If voices aren't loaded yet, wait for them
      if (voices.length === 0) {
        return;
      }

      let englishVoices = voices.filter(v => v.lang.startsWith('en'));

      // Filter out blacklisted low-quality/novelty voices
      englishVoices = englishVoices.filter(v => !isBlacklisted(v));

      // Deduplicate voices with the same name (macOS returns duplicates at different quality levels)
      const seenNames = new Set();
      englishVoices = englishVoices.filter(v => {
        if (seenNames.has(v.name)) return false;
        seenNames.add(v.name);
        return true;
      });

      // Ensure we have a default voice selected
      initDefaultVoice();

      // Filter out cloud voices if toggle is off
      if (!cloudVoicesEnabled) {
        englishVoices = englishVoices.filter(v => !isCloudVoice(v));
      }

      // Check if any cloud voices exist
      const allVoices = speechSynthesis.getVoices();
      const hasCloudVoices = allVoices.some(v => v.lang.startsWith('en') && isCloudVoice(v));

      // Sort: Recommended first, then Cloud (if enabled), then Premium/Enhanced, then alphabetical
      englishVoices.sort((a, b) => {
        const aRec = isRecommended(a);
        const bRec = isRecommended(b);
        // Recommended voices at the very top
        if (aRec && !bRec) return -1;
        if (!aRec && bRec) return 1;
        const aCloud = isCloudVoice(a);
        const bCloud = isCloudVoice(b);
        // Cloud voices next when enabled
        if (aCloud && !bCloud) return -1;
        if (!aCloud && bCloud) return 1;
        const aPremium = a.name.includes('Premium') || a.name.includes('Enhanced');
        const bPremium = b.name.includes('Premium') || b.name.includes('Enhanced');
        if (aPremium && !bPremium) return -1;
        if (!aPremium && bPremium) return 1;
        return a.name.localeCompare(b.name);
      });

      voiceList.innerHTML = '';

      // Update toggle state and visibility
      const toggle = document.getElementById('cloudVoicesToggle');
      const toggleContainer = document.querySelector('.cloud-toggle');
      if (toggle) toggle.checked = cloudVoicesEnabled;
      if (toggleContainer) toggleContainer.style.display = hasCloudVoices ? '' : 'none';

      // Update current voice display
      const currentVoiceEl = document.getElementById('currentVoiceName');
      if (currentVoiceEl) {
        currentVoiceEl.textContent = selectedVoiceName || 'None selected';
      }

      englishVoices.forEach(voice => {
        const isSelected = selectedVoiceName === voice.name;
        const isCloud = isCloudVoice(voice);
        const isRec = isRecommended(voice);
        const item = document.createElement('div');
        item.className = `voice-item${isSelected ? ' selected' : ''}`;
        item.dataset.voiceName = voice.name;

        let badges = '';
        if (isRec) badges += '<span class="voice-recommended-badge">recommended</span>';
        if (isCloud) badges += '<span class="voice-cloud-badge">cloud</span>';

        item.innerHTML = `
          <div class="voice-radio"></div>
          <div class="voice-info">
            <div class="voice-name">${voice.name}${badges}</div>
            <div class="voice-lang">${voice.lang}</div>
          </div>
          <button class="voice-preview">Preview</button>
        `;

        item.addEventListener('click', (e) => {
          if (e.target.classList.contains('voice-preview')) return;
          selectVoice(voice.name);
        });

        item.querySelector('.voice-preview').addEventListener('click', (e) => {
          e.stopPropagation();
          previewVoice(voice);
        });

        voiceList.appendChild(item);
      });
    }

    function selectVoice(voiceName) {
      selectedVoiceName = voiceName;
      localStorage.setItem('selectedVoice', voiceName);
      document.querySelectorAll('.voice-item').forEach(item => {
        const name = item.dataset.voiceName;
        item.classList.toggle('selected', name === voiceName);
      });
      // Update current voice display
      const currentVoiceEl = document.getElementById('currentVoiceName');
      if (currentVoiceEl) {
        currentVoiceEl.textContent = voiceName;
      }
    }

    function previewVoice(voice) {
      speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance("Hello! I'm your voice assistant.");
      utterance.voice = voice;
      speechSynthesis.speak(utterance);
    }

    function openVoiceSettings() {
      voiceModal.classList.remove('hidden');

      // Try to populate immediately
      populateVoiceList();

      // If voices weren't ready, wait for them
      const voices = speechSynthesis.getVoices();
      if (voices.length === 0) {
        // Set up a one-time handler to populate when voices load
        const onVoicesReady = () => {
          populateVoiceList();
          speechSynthesis.removeEventListener('voiceschanged', onVoicesReady);
        };
        speechSynthesis.addEventListener('voiceschanged', onVoicesReady);
      }
    }

    function closeVoiceSettings() {
      speechSynthesis.cancel();
      voiceModal.classList.add('hidden');
    }

    // ============ Event Listeners ============
    function setupEventListeners() {
      loginBtn.addEventListener('click', startOAuthFlow);
      logoutBtn.addEventListener('click', () => {
        settingsDropdown.classList.remove('open');
        logout();
      });

      // Main button click
      mainButton.addEventListener('click', () => {
        if (isSpeaking || speechQueue.length > 0) {
          stopSpeaking();
        }
        if (isListening) {
          stopRecording();
        } else {
          startRecording();
        }
      });

      // Spacebar
      document.addEventListener('keydown', (e) => {
        if (!voiceModal.classList.contains('hidden')) return;
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        if (!apiKey) return;

        if (e.code === 'Space') {
          e.preventDefault();
          if (isSpeaking || speechQueue.length > 0) {
            stopSpeaking();
          }
          if (isListening) {
            stopRecording();
          } else {
            startRecording();
          }
        }
      });

      // Settings dropdown menu
      settingsMenuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        settingsDropdown.classList.toggle('open');
      });

      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!settingsDropdown.contains(e.target) && e.target !== settingsMenuBtn) {
          settingsDropdown.classList.remove('open');
        }
      });

      // Voice settings from dropdown
      voiceSettingsBtn.addEventListener('click', () => {
        settingsDropdown.classList.remove('open');
        openVoiceSettings();
      });

      // Cost settings from dropdown
      costSettingsBtn.addEventListener('click', openCostModal);

      // Copy chat
      copyChatBtn.addEventListener('click', copyChat);

      // Cost modal
      costModalClose.addEventListener('click', closeCostModal);
      costModal.addEventListener('click', (e) => {
        if (e.target === costModal) closeCostModal();
      });

      // About modal
      aboutBtn.addEventListener('click', () => {
        settingsDropdown.classList.remove('open');
        aboutModal.classList.remove('hidden');
      });
      aboutModalClose.addEventListener('click', () => {
        aboutModal.classList.add('hidden');
      });
      aboutModal.addEventListener('click', (e) => {
        if (e.target === aboutModal) aboutModal.classList.add('hidden');
      });

      // Privacy modal
      privacyBtn.addEventListener('click', () => {
        settingsDropdown.classList.remove('open');
        privacyModal.classList.remove('hidden');
      });
      privacyModalClose.addEventListener('click', () => {
        privacyModal.classList.add('hidden');
      });
      privacyModal.addEventListener('click', (e) => {
        if (e.target === privacyModal) privacyModal.classList.add('hidden');
      });

      // Search toggle
      searchToggle.addEventListener('click', () => {
        webSearchEnabled = !webSearchEnabled;
        localStorage.setItem('webSearchEnabled', webSearchEnabled);
        updateSearchToggleUI();
      });

      // Stop button
      stopBtn.addEventListener('click', stopSpeaking);

      // Voice modal
      modalClose.addEventListener('click', closeVoiceSettings);
      voiceModal.addEventListener('click', (e) => {
        if (e.target === voiceModal) closeVoiceSettings();
      });

      // Cloud voices toggle
      document.getElementById('cloudVoicesToggle').addEventListener('change', (e) => {
        cloudVoicesEnabled = e.target.checked;
        localStorage.setItem('cloudVoicesEnabled', cloudVoicesEnabled);
        // If turning off cloud voices and current selection is a cloud voice, clear it
        if (!cloudVoicesEnabled && selectedVoiceName) {
          const voices = speechSynthesis.getVoices();
          const currentVoice = voices.find(v => v.name === selectedVoiceName);
          if (currentVoice && isCloudVoice(currentVoice)) {
            selectedVoiceName = null;
            localStorage.removeItem('selectedVoice');
          }
        }
        populateVoiceList();
      });

      // Load voices and init default at startup
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = () => {
          initDefaultVoice();
          // Update voice list if modal is open
          if (!voiceModal.classList.contains('hidden')) {
            populateVoiceList();
          }
        };
      }
      // Also try immediately in case voices are already loaded
      initDefaultVoice();

      // Mode switching - click anywhere in the toggle container to switch
      modeToggle.addEventListener('click', () => setTextMode(!textMode));

      // New chat
      newChatBtn.addEventListener('click', startNewChat);

      // Text input handling
      textInput.addEventListener('input', () => {
        // Auto-resize textarea
        textInput.style.height = 'auto';
        textInput.style.height = Math.min(textInput.scrollHeight, 160) + 'px';

        // Update send button state
        textSendBtn.classList.toggle('active', textInput.value.trim().length > 0);
      });

      textInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          submitTextMessage();
        }
      });

      textSendBtn.addEventListener('click', submitTextMessage);

      function submitTextMessage() {
        const text = textInput.value.trim();
        if (text && !isProcessingText) {
          textInput.value = '';
          textInput.style.height = 'auto';
          textSendBtn.classList.remove('active');
          textInput.blur(); // Hide keyboard on mobile
          sendTextToAPI(text);
        }
      }

      // Mobile keyboard handling - keep input above virtual keyboard
      if (window.visualViewport) {
        const baseBottom = 88; // 5.5rem in pixels

        function adjustForKeyboard() {
          const viewport = window.visualViewport;
          const keyboardHeight = window.innerHeight - viewport.height - viewport.offsetTop;

          if (keyboardHeight > 100) {
            // Keyboard is open
            textInputContainer.style.bottom = (keyboardHeight + 12) + 'px';
          } else {
            // Keyboard is closed
            textInputContainer.style.bottom = '';
          }
        }

        window.visualViewport.addEventListener('resize', adjustForKeyboard);
        window.visualViewport.addEventListener('scroll', adjustForKeyboard);
      }

    }

    // ============ Start ============
    init();
  </script>
</body>
</html>
